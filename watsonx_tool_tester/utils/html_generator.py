#!/usr/bin/env python3
"""
HTML Report Generator for WatsonX Tool Tester.

This module provides functionality to generate beautiful HTML reports
from test results with interactive features and modern styling.
"""

import datetime
import os
from typing import Any, Dict, List, Optional

from .history_manager import HistoryManager


class HTMLReportGenerator:
    """Generator for HTML reports from test results."""

    def __init__(self, history_manager: Optional[HistoryManager] = None):
        """Initialize the HTML report generator.

        Args:
            history_manager: Optional history manager for historical data
        """
        self.title = "WatsonX Tool Test Report"
        self.description = (
            "Comprehensive analysis of AI model tool calling capabilities"
        )
        self.history_manager = history_manager

    def generate_html_report(
        self,
        results: List[Dict[str, Any]],
        summary: Dict[str, Any],
        config: Optional[Dict[str, Any]] = None,
        include_history: bool = True,
    ) -> str:
        """Generate a complete HTML report from test results.

        Args:
            results: List of test result dictionaries
            summary: Summary statistics dictionary
            config: Optional configuration information
            include_history: Whether to include historical data

        Returns:
            str: Complete HTML report as a string
        """
        # Generate report timestamp
        timestamp = datetime.datetime.utcnow().strftime(
            "%Y-%m-%d %H:%M:%S UTC"
        )

        # Build HTML structure
        html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.title}</title>
    <style>
        {self._get_css_styles()}
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>{self.title}</h1>
            <p class="subtitle">{self.description}</p>
            <div class="meta-info">
                <span class="timestamp">Generated: {timestamp}</span>
                {self._generate_config_info(config)}
            </div>
        </header>

        <main>
            {self._generate_summary_section(summary, results)}
            {self._generate_history_section() if include_history and self.history_manager else ''}
            {self._generate_results_section(results, config)}
        </main>

        <footer class="footer">
            <p>Generated by WatsonX Tool Tester | <a href="https://github.com/daniel-butler-irl/watsonx_model_tool_test">GitHub Repository</a></p>
        </footer>
    </div>

    <script>
        {self._get_javascript()}
    </script>
</body>
</html>
"""
        return html_content

    def _get_css_styles(self) -> str:
        """Generate CSS styles for the HTML report."""
        return """
        :root {
            --primary-color: #0f62fe;
            --success-color: #24a148;
            --warning-color: #f1c21b;
            --error-color: #da1e28;
            --background-color: #f4f4f4;
            --card-background: #ffffff;
            --text-color: #161616;
            --border-color: #e0e0e0;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), #0043ce);
            color: white;
            padding: 40px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .meta-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .timestamp {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 15px;
        }

        .config-info {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .config-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 15px;
        }

        .section {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }

        .section h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
        }

        .summary-card h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .summary-card .value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-card .description {
            color: #666;
            font-size: 0.9em;
        }

        .status-indicators {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .new-label {
            background: linear-gradient(135deg, #9333ea, #7c3aed);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(147, 51, 234, 0.3);
        }

        .variable-label {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(245, 158, 11, 0.3);
            cursor: help;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
        }

        .results-table th:nth-child(2),
        .results-table th:nth-child(3),
        .results-table th:nth-child(4),
        .results-table td:nth-child(2),
        .results-table td:nth-child(3),
        .results-table td:nth-child(4) {
            text-align: center;
        }

        .results-table th {
            background: var(--background-color);
            font-weight: 600;
            color: var(--primary-color);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .results-table tr:hover {
            background: rgba(15, 98, 254, 0.05);
        }

        .model-name {
            font-weight: 600;
            color: var(--primary-color);
        }

        .support-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .support-yes {
            background: #d4edda;
            color: #155724;
        }

        .support-no {
            background: #f8d7da;
            color: #721c24;
        }

        .support-partial {
            background: #fff3cd;
            color: #856404;
        }

        .timing-info {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
        }

        .details-cell {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .details-cell:hover {
            overflow: visible;
            white-space: normal;
            word-wrap: break-word;
        }

        .reliability-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .reliability-perfect {
            background: #d4edda;
            color: #155724;
        }

        .reliability-partial {
            background: #fff3cd;
            color: #856404;
        }

        .reliability-none {
            background: #f8d7da;
            color: #721c24;
        }

        .chart-container {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            margin: 20px 0;
        }

        .chart-title {
            color: var(--primary-color);
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
        }

        .performance-chart {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .performance-item {
            flex: 1;
            min-width: 200px;
            text-align: center;
            padding: 15px;
            background: var(--background-color);
            border-radius: var(--border-radius);
        }

        .performance-value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .performance-label {
            color: #666;
            font-size: 0.9em;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 500;
            color: var(--text-color);
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9em;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(15, 98, 254, 0.1);
        }

        .footer {
            text-align: center;
            padding: 20px;
            color: #666;
            border-top: 1px solid var(--border-color);
            margin-top: 40px;
        }

        .footer a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .collapsible {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin: 10px 0;
            overflow: hidden;
        }

        .collapsible-header {
            background: var(--card-background);
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            transition: background 0.2s ease;
        }

        .collapsible-header:hover {
            background: rgba(15, 98, 254, 0.05);
        }

        .collapsible-content {
            padding: 15px;
            display: none;
        }

        .collapsible-content.active {
            display: block;
        }

        .expand-icon {
            transition: transform 0.2s ease;
        }

        .expand-icon.rotated {
            transform: rotate(180deg);
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .summary-grid {
                grid-template-columns: 1fr;
            }

            .results-table {
                font-size: 0.9em;
            }

            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .performance-chart {
                flex-direction: column;
            }
        }

        /* History Section Styles */
        .history-section {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
            overflow-x: auto;
        }
        
        .history-container {
            min-width: 800px;
            width: 100%;
        }

        .history-legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .history-chart {
            background: #fafafa;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow-x: auto;
            overflow-y: hidden;
        }

        .chart-header {
            display: flex;
            background: #f0f0f0;
            border-bottom: 1px solid var(--border-color);
            min-width: max-content;
        }

        .model-header {
            min-width: 200px;
            max-width: 250px;
            padding: 12px;
            font-weight: 600;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .timeline-header {
            display: flex;
            flex: 1;
            min-width: 0;
        }

        .date-header {
            min-width: 24px;
            flex: 1;
            padding: 12px 2px;
            text-align: center;
            font-size: 0.7em;
            color: #666;
            writing-mode: vertical-lr;
            text-orientation: mixed;
            white-space: nowrap;
        }

        .chart-body {
            max-height: 600px;
            overflow-y: auto;
        }

        .model-row {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            min-width: max-content;
        }

        .model-row:last-child {
            border-bottom: none;
        }

        .model-info {
            min-width: 200px;
            max-width: 250px;
            padding: 12px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .model-name {
            font-weight: 600;
            font-size: 0.9em;
        }


        .status-timeline {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 8px 0;
            min-width: 0;
        }

        .status-cell {
            min-width: 24px;
            height: 24px;
            flex: 1;
            margin: 0 1px;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .status-working {
            background-color: var(--success-color);
        }

        .status-partial {
            background-color: #ff8c00;
        }

        .status-broken {
            background-color: #8b0000;
        }

        .status-not_supported {
            background-color: #e0e0e0;
        }

        .status-unreliable {
            background-color: #ffd700;
        }

        .status-untested {
            background-color: #e0e0e0;
        }

        .status-cell:hover {
            transform: scale(1.2);
            transition: transform 0.2s ease;
            z-index: 10;
            position: relative;
        }
        
        .status-cell[title] {
            white-space: pre-line;
        }
        
        /* Responsive adjustments for timeline */
        @media (max-width: 1200px) {
            .date-header {
                font-size: 0.6em;
                min-width: 20px;
            }
            
            .status-cell {
                min-width: 20px;
                height: 20px;
            }
        }
        
        @media (max-width: 900px) {
            .history-container {
                min-width: 600px;
            }
            
            .model-header,
            .model-info {
                min-width: 150px;
                max-width: 150px;
            }
            
            .date-header {
                font-size: 0.5em;
                min-width: 18px;
            }
            
            .status-cell {
                min-width: 18px;
                height: 18px;
            }
        }
        
        @media (max-width: 768px) {
            .history-section {
                padding: 16px;
            }
            
            .history-container {
                min-width: 500px;
            }
            
            .model-header,
            .model-info {
                min-width: 120px;
                max-width: 120px;
                font-size: 0.9em;
            }
            
            .date-header {
                font-size: 0.4em;
                min-width: 16px;
                padding: 8px 1px;
            }
            
            .status-cell {
                min-width: 16px;
                height: 16px;
            }
            
            .chart-body {
                max-height: 400px;
            }
        }
        
        @media (max-width: 480px) {
            .history-container {
                min-width: 400px;
            }
            
            .model-header,
            .model-info {
                min-width: 100px;
                max-width: 100px;
                font-size: 0.8em;
                padding: 8px;
            }
            
            .date-header {
                font-size: 0.3em;
                min-width: 14px;
                padding: 6px 1px;
            }
            
            .status-cell {
                min-width: 14px;
                height: 14px;
                margin: 0 0.5px;
            }
            
            .chart-body {
                max-height: 300px;
            }
            
            .history-legend {
                flex-direction: column;
                gap: 10px;
            }
            
            .legend-item {
                font-size: 0.9em;
            }
        }

        /* Detailed History Section Styles */
        .detailed-history {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .error-analysis,
        .performance-trends,
        .detailed-results {
            margin-bottom: 30px;
        }

        .error-item {
            display: flex;
            gap: 10px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: #fff3f3;
        }

        .error-count {
            font-weight: bold;
            color: var(--error-color);
            min-width: 50px;
            text-align: center;
        }

        .error-message {
            flex: 1;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-value {
            font-weight: bold;
            color: var(--primary-color);
        }

        .trends-table {
            width: 100%;
            border-collapse: collapse;
        }

        .trends-header {
            background: var(--background-color);
            font-weight: 600;
            color: var(--primary-color);
        }

        .trend-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .trend-date {
            width: 100px;
            color: #666;
        }

        /* Recent Test Details Table Styles */
        .details-table {
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
        }

        .details-header {
            display: flex;
            background: var(--background-color);
            font-weight: 600;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
        }

        .details-header > div {
            padding: 12px;
            border-right: 1px solid var(--border-color);
        }

        .details-header > div:last-child {
            border-right: none;
        }

        .detail-row {
            display: flex;
            align-items: center;
            padding: 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .detail-row:hover {
            background: rgba(15, 98, 254, 0.05);
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-row > div {
            padding: 12px;
            border-right: 1px solid var(--border-color);
        }

        .detail-row > div:last-child {
            border-right: none;
        }

        .detail-date {
            width: 80px;
            min-width: 80px;
            font-size: 0.9em;
            color: #666;
        }

        .detail-model {
            width: 300px;
            min-width: 300px;
            font-weight: 500;
            color: var(--primary-color);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .detail-status {
            width: 120px;
            min-width: 120px;
            text-align: center;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .detail-status.working {
            background: #d4edda;
            color: #155724;
        }

        .detail-status.partial {
            background: #fff3cd;
            color: #856404;
        }

        .detail-status.broken {
            background: #f8d7da;
            color: #721c24;
        }

        .detail-status.not-supported {
            background: #e9ecef;
            color: #495057;
        }

        .detail-status.unreliable {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .detail-time {
            width: 80px;
            min-width: 80px;
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
            text-align: right;
        }

        .detail-success {
            width: 100px;
            min-width: 100px;
            font-family: monospace;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: right;
        }

        .detail-details {
            flex: 1;
            min-width: 300px;
            font-size: 0.9em;
            color: #666;
            padding: 8px;
            background: #f8f9fa;
            border-left: 3px solid #dee2e6;
            border-radius: 4px;
        }

        .details-content {
            max-height: 200px;
            overflow-y: auto;
        }

        .details-content h5 {
            margin: 0 0 8px 0;
            font-size: 0.95em;
            color: var(--primary-color);
        }

        .details-content p {
            margin: 4px 0;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .expanded-content h5 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .expanded-content p {
            margin-bottom: 8px;
            word-wrap: break-word;
        }

        .expanded-content strong {
            color: #495057;
        }

        /* Unsupported Models Section Styles */
        .unsupported-models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .unsupported-model-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            transition: background-color 0.2s ease;
        }

        .unsupported-model-item:hover {
            background: #f5f5f5;
        }

        .unsupported-model-item .model-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 0.95em;
        }

        .unsupported-model-item .model-details {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
        }

        .expand-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            cursor: pointer;
            margin-left: 8px;
            transition: background-color 0.2s ease;
        }

        .expand-btn:hover {
            background: #2563eb;
        }

        .full-details {
            display: block;
            margin-top: 8px;
            font-style: normal;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .model-row,
            .detail-row,
            .trend-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .model-info,
            .detail-info {
                width: 100%;
                padding: 10px 0;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .status-timeline {
                flex-direction: column;
                align-items: flex-start;
            }

            .status-cell {
                width: 100%;
                height: auto;
                padding: 8px;
                margin: 4px 0;
                border-radius: 10px;
            }

            .error-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .stat-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .trend-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .detail-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .detail-row > div {
                width: 100% !important;
                min-width: auto !important;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                padding: 8px 12px;
            }

            .detail-row > div:last-child {
                border-bottom: none;
            }

            .details-header {
                display: none;
            }

            .detail-date::before {
                content: "Date: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-model::before {
                content: "Model: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-status::before {
                content: "Status: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-time::before {
                content: "Time: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-success::before {
                content: "Tool Success: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .unsupported-models-grid {
                grid-template-columns: 1fr;
            }
        }
        """

    def _generate_config_info(
        self, config: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate configuration information section."""
        if not config:
            return ""

        config_items = []

        # Add key configuration items
        if config.get("iterations"):
            config_items.append(
                f'<span class="config-item">Iterations: {config["iterations"]}</span>'
            )

        if config.get("client_type"):
            config_items.append(
                f'<span class="config-item">Client: {config["client_type"]}</span>'
            )

        if config.get("total_models"):
            config_items.append(
                f'<span class="config-item">Models Tested: {config["total_models"]}</span>'
            )

        if config_items:
            return f'<div class="config-info">{"".join(config_items)}</div>'

        return ""

    def _generate_summary_section(
        self, summary: Dict[str, Any], results: List[Dict[str, Any]]
    ) -> str:
        """Generate the summary statistics section."""
        # Calculate percentages
        total_count = summary.get("total_count", 0)
        supported_count = summary.get("supported_count", 0)
        handles_response_count = summary.get("handles_response_count", 0)

        support_percentage = (
            (supported_count / total_count * 100) if total_count > 0 else 0
        )
        handling_percentage = (
            (handles_response_count / supported_count * 100)
            if supported_count > 0
            else 0
        )

        # Generate reliability info
        reliability_info = ""
        if "reliability" in summary:
            rel_stats = summary["reliability"]
            reliable_count = rel_stats.get("reliable_count", 0)
            total_tested = rel_stats.get("total_tested", 0)

            # Use supported_count instead of total_tested for display consistency
            # since total_tested might still include unsupported models in some cases
            display_total = (
                supported_count if supported_count > 0 else total_tested
            )
            reliability_percentage = (
                (reliable_count / display_total * 100)
                if display_total > 0
                else 0
            )

            reliability_info = f"""
            <div class="summary-card">
                <h3>Reliability</h3>
                <div class="value" style="color: var(--success-color);">{reliable_count}/{display_total}</div>
                <div class="description">Models with 100% consistency ({reliability_percentage:.1f}%)</div>
            </div>
            """

        # Generate performance info
        performance_info = ""
        if summary.get("fastest_model"):
            fastest = summary["fastest_model"]
            performance_info = f"""
            <div class="summary-card">
                <h3>Fastest Model</h3>
                <div class="value" style="color: var(--primary-color);">{fastest['time']:.2f}s</div>
                <div class="description">{fastest['model']}</div>
            </div>
            """

        # Status indicators - calculate based on actual model states
        full_support = 0
        partial_support = 0
        no_support = 0

        # Count based on the actual results data
        for result in results:
            tool_support = result.get("tool_call_support", False)
            handles_response = result.get("handles_response", False)
            is_reliable = result.get("reliability", {}).get(
                "is_reliable", True
            )

            if tool_support and handles_response and is_reliable:
                full_support += 1
            elif tool_support and not handles_response:
                partial_support += 1
            elif not tool_support:
                no_support += 1
            # Note: unreliable models (tool_support=True, handles_response=True, is_reliable=False)
            # are not counted in these simple categories as they're a separate concern

        return f"""
        <section class="section">
            <h2>üìä Summary Statistics</h2>
            <div class="summary-grid">
                <div class="summary-card">
                    <h3>Total Models</h3>
                    <div class="value">{total_count}</div>
                    <div class="description">Models tested</div>
                </div>
                <div class="summary-card">
                    <h3>Tool Support</h3>
                    <div class="value" style="color: var(--success-color);">{supported_count}</div>
                    <div class="description">Models with tool calling ({support_percentage:.1f}%)</div>
                </div>
                <div class="summary-card">
                    <h3>Response Handling</h3>
                    <div class="value" style="color: var(--success-color);">{handles_response_count}</div>
                    <div class="description">Models using tool results ({handling_percentage:.1f}%)</div>
                </div>
                {reliability_info}
                {performance_info}
                <div class="summary-card">
                    <h3>Average Response Time</h3>
                    <div class="value" style="color: var(--primary-color);">{summary.get('avg_total_time', 0):.2f}s</div>
                    <div class="description">Total processing time</div>
                </div>
            </div>

            <div class="status-indicators">
                <div class="status-badge status-success">
                    <span>‚úÖ</span>
                    <span>Full Support: {full_support}</span>
                </div>
                <div class="status-badge status-warning">
                    <span>‚ö†Ô∏è</span>
                    <span>Partial Support: {partial_support}</span>
                </div>
                <div class="status-badge status-error">
                    <span>‚ùå</span>
                    <span>No Support: {no_support}</span>
                </div>
            </div>
        </section>
        """

    def _generate_results_section(
        self,
        results: List[Dict[str, Any]],
        config: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Generate the detailed results table section."""
        # Group results by model to handle conflicting results
        model_results = {}
        for result in results:
            model_id = result.get("model", "unknown")
            if model_id not in model_results:
                model_results[model_id] = []
            model_results[model_id].append(result)
        
        # Process each model to get the best representation
        supported_results = []
        unsupported_results = []
        
        for model_id, model_data in model_results.items():
            # Sort by most recent or most successful test
            model_data.sort(key=lambda x: (
                x.get("tool_call_support", False),  # Prefer supported
                x.get("handles_response", False),   # Prefer handling response
                x.get("total_time", 0)              # Prefer faster (ascending)
            ), reverse=True)
            
            # Use the best result for this model
            best_result = model_data[0]
            
            # Add metadata about conflicting results if they exist
            if len(model_data) > 1:
                conflicting_statuses = set(r.get("tool_call_support", False) for r in model_data)
                if len(conflicting_statuses) > 1:
                    best_result["has_conflicting_results"] = True
                    best_result["total_test_runs"] = len(model_data)
                    # Add note to details
                    original_details = best_result.get("details", "")
                    best_result["details"] = f"{original_details} (Variable results: {len(model_data)} tests)"
            
            # Categorize based on the best result
            if best_result.get("tool_call_support", False):
                supported_results.append(best_result)
            else:
                unsupported_results.append(best_result)

        # Check if we have reliability data (but we won't show the column)
        has_reliability = any("reliability" in result for result in results)

        # Generate main results table (supported models only)
        main_results_html = self._generate_results_table(
            supported_results, has_reliability, "supported"
        )

        # Generate unsupported models section
        unsupported_section = ""
        if unsupported_results:
            unsupported_section = self._generate_unsupported_models_section(
                unsupported_results
            )

        # Generate recent test details section if history is available
        recent_test_details = ""
        if self.history_manager:
            detailed_results = self.history_manager.get_detailed_test_results(
                days=30
            )
            if detailed_results:
                recent_test_details = (
                    self._generate_recent_test_details_section(
                        detailed_results
                    )
                )

        return f"""
        {main_results_html}
        {recent_test_details}
        {unsupported_section}
        """

    def _generate_recent_test_details_section(
        self, detailed_results: List[Dict[str, Any]]
    ) -> str:
        """Generate the recent test details section as a standalone section."""
        if not detailed_results:
            return ""

        recent_results = detailed_results[-50:]  # Last 50 detailed results
        detail_rows = []

        for result in recent_results:
            # Determine status based on support and reliability
            tool_support = result["tool_call_support"]
            handles_response = result["handles_response"]
            is_reliable = result.get("is_reliable", True)

            # Check if this is a model that never supported tool calling vs one that is broken
            error_message = result["test_details"].get("error_message", "")
            details = result["test_details"].get("details", "")

            # Models that explicitly don't support tool calling
            is_not_supported = not tool_support and (
                "not support" in error_message.lower()
                or "not support" in details.lower()
                or "function" in error_message.lower()
                and "not support" in error_message.lower()
            )

            if is_not_supported:
                status_class = "not-supported"
                status_text = "Not Supported"
            elif tool_support and handles_response and is_reliable:
                status_class = "working"
                status_text = "Working"
            elif tool_support and handles_response and not is_reliable:
                status_class = "unreliable"
                status_text = "Unreliable"
            elif tool_support and not handles_response:
                status_class = "partial"
                status_text = "Partial"
            else:
                status_class = "broken"
                status_text = "Broken"

            detail_rows.append(
                f"""
                <div class="detail-row" data-model="{result['model_id']}">
                    <div class="detail-date">{result['date']}</div>
                    <div class="detail-model">{result['model_info']['display_name']}{self._generate_new_label(result['model_id'])}</div>
                    <div class="detail-status {status_class}">{status_text}</div>
                    <div class="detail-time">{result['performance']['total_time']:.3f}s</div>
                    <div class="detail-success">{result['performance'].get('tool_success_rate', 0):.1%}</div>
                    <div class="detail-details">
                        <div class="details-content">
                            <h5>Test Details</h5>
                            {f'<p><strong>Error:</strong> {result["test_details"]["error_message"]}</p>' if result["test_details"].get("error_message") else ''}
                            {f'<p><strong>Expected:</strong> {result["test_details"]["expected_result"][:200]}{"..." if len(result["test_details"]["expected_result"]) > 200 else ""}</p>' if result["test_details"].get("expected_result") else ''}
                            {f'<p><strong>Actual:</strong> {result["test_details"]["actual_result"][:200]}{"..." if len(result["test_details"]["actual_result"]) > 200 else ""}</p>' if result["test_details"].get("actual_result") else ''}
                            <p><strong>Details:</strong> {result['test_details']['details']}</p>
                        </div>
                    </div>
                </div>
            """
            )

        return f"""
        <section class="section">
            <h2>üìã Recent Test Details</h2>
            <div class="detailed-results">
                <div class="details-table">
                    <div class="details-header">
                        <div class="detail-date">Date</div>
                        <div class="detail-model">Model</div>
                        <div class="detail-status">Status</div>
                        <div class="detail-time">Time</div>
                        <div class="detail-success">Tool Success</div>
                        <div class="detail-details">Details</div>
                    </div>
                    {''.join(detail_rows)}
                </div>
            </div>
        </section>
        """

    def _generate_results_table(
        self,
        results: List[Dict[str, Any]],
        has_reliability: bool,
        table_type: str,
    ) -> str:
        """Generate a results table for the given results."""
        # Generate table rows
        rows = []
        for result in results:
            model_name = result.get("model", "Unknown")
            tool_support = result.get("tool_call_support", False)
            handles_response = result.get("handles_response", False)
            details = result.get("details", "N/A")

            # Calculate tool successes for use in both tool support and response handling
            tool_successes = 0
            iterations = 1

            # Format tool support with reliability context
            if has_reliability and "reliability" in result:
                rel_info = result["reliability"]
                is_reliable = rel_info.get("is_reliable")
                tool_success_rate = rel_info.get("tool_call_success_rate", 0)
                iterations = rel_info.get("iterations", 1)

                # Calculate actual success count from rate and iterations
                tool_successes = int(tool_success_rate * iterations)

                # Show success/total format for supported models (only consider tool calling success)
                if tool_support and is_reliable is not None:
                    if tool_success_rate == 1.0:
                        tool_support_html = f'<span class="support-indicator support-yes">‚úÖ Reliable ({tool_successes}/{iterations})</span>'
                    else:
                        tool_support_html = f'<span class="support-indicator support-partial">‚ö†Ô∏è Unreliable ({tool_successes}/{iterations})</span>'
                elif not tool_support:
                    # For unsupported models, show 0/iterations
                    tool_support_html = f'<span class="support-indicator support-no">‚ùå Not Supported (0/{iterations})</span>'
                else:
                    tool_support_html = f'<span class="support-indicator support-{"yes" if tool_support else "no"}">{"‚úÖ Yes" if tool_support else "‚ùå No"}</span>'
            else:
                # For models without reliability data, assume 1 success if tool_support is True
                tool_successes = 1 if tool_support else 0
                tool_support_html = f'<span class="support-indicator support-{"yes" if tool_support else "no"}">{"‚úÖ Yes" if tool_support else "‚ùå No"}</span>'

            # Format response handling with reliability context
            if has_reliability and "reliability" in result:
                rel_info = result["reliability"]
                is_reliable = rel_info.get("is_reliable")
                response_success_rate = rel_info.get(
                    "response_handling_success_rate", 0
                )

                # Calculate actual success count from rate and tool_successes
                response_successes = (
                    int(response_success_rate * tool_successes)
                    if tool_successes > 0
                    else 0
                )

                # Show response handling based on model support
                if not tool_support:
                    # For unsupported models, show N/A
                    response_support_html = '<span class="support-indicator" style="color: #888;">N/A</span>'
                elif tool_support and tool_successes > 0:
                    # For supported models, show success/attempts format
                    if response_success_rate == 1.0:
                        response_support_html = f'<span class="support-indicator support-yes">‚úÖ Correct ({response_successes}/{tool_successes})</span>'
                    elif response_success_rate > 0:
                        response_support_html = f'<span class="support-indicator support-partial">‚ö†Ô∏è Partial ({response_successes}/{tool_successes})</span>'
                    else:
                        response_support_html = f'<span class="support-indicator support-no">‚ùå Never Handles (0/{tool_successes})</span>'
                else:
                    response_support_html = f'<span class="support-indicator support-{"yes" if handles_response else "no"}">{"‚úÖ Yes" if handles_response else "‚ùå No"}</span>'
            else:
                response_support_html = f'<span class="support-indicator support-{"yes" if handles_response else "no"}">{"‚úÖ Yes" if handles_response else "‚ùå No"}</span>'

            # Reliability info is now shown in tooltips only, not in a separate column

            # Format timing info
            # Handle both nested response_times structure and flat CSV structure
            times = result.get("response_times", {})

            # Try nested structure first, then fall back to flat CSV columns
            call_time = times.get("tool_call_time", 0) or result.get("tool_call_time", 0)
            resp_time = times.get("response_processing_time", 0) or result.get("response_time", 0)
            total_time = times.get("total_time", 0) or result.get("total_time", 0)

            call_time_html = (
                f'<span class="timing-info">{call_time:.2f}s</span>'
                if call_time
                else "N/A"
            )
            resp_time_html = (
                f'<span class="timing-info">{resp_time:.2f}s</span>'
                if resp_time
                else "N/A"
            )
            total_time_html = (
                f'<span class="timing-info">{total_time:.2f}s</span>'
                if total_time
                else "N/A"
            )

            # Truncate details for display
            details_html = f'<span class="details-cell" title="{details}">{details}</span>'

            # No reliability column

            row = f"""
            <tr data-model="{model_name.lower()}" data-support="{tool_support}" data-handling="{handles_response}">
                <td class="model-name">{model_name}{self._generate_new_label(model_name)}{self._generate_variable_label(result)}</td>
                <td>{tool_support_html}</td>
                <td>{response_support_html}</td>
                <td>{call_time_html}</td>
                <td>{resp_time_html}</td>
                <td>{total_time_html}</td>
                <td>{details_html}</td>
            </tr>
            """
            rows.append(row)

        # Determine section title and filter controls based on table type
        section_title = (
            "üîç Models with Tool Support"
            if table_type == "supported"
            else "üîç Detailed Results"
        )
        filter_controls = ""
        if table_type == "supported":
            filter_controls = """
            <div class="filter-controls">
                <div class="filter-group">
                    <label for="model-filter">Filter by Model:</label>
                    <input type="text" id="model-filter" class="filter-input" placeholder="Enter model name...">
                </div>
                <div class="filter-group">
                    <label for="reliability-filter">Reliability:</label>
                    <select id="reliability-filter" class="filter-input">
                        <option value="">All</option>
                        <option value="reliable">Reliable</option>
                        <option value="unreliable">Unreliable</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="handling-filter">Response Handling:</label>
                    <select id="handling-filter" class="filter-input">
                        <option value="">All</option>
                        <option value="true">Correct</option>
                        <option value="false">Incorrect</option>
                    </select>
                </div>
            </div>
            """

        return f"""
        <section class="section">
            <h2>{section_title}</h2>

            {filter_controls}

            <table class="results-table" id="results-table">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Tool Support</th>
                        <th>Response Handling</th>
                        <th>Call Time</th>
                        <th>Response Time</th>
                        <th>Total Time</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    {"".join(rows)}
                </tbody>
            </table>
        </section>
        """

    def _generate_unsupported_models_section(
        self, unsupported_results: List[Dict[str, Any]]
    ) -> str:
        """Generate a section for models that don't support tool calling."""
        if not unsupported_results:
            return ""

        # Create a simple list of unsupported models
        model_items = []
        for i, result in enumerate(unsupported_results):
            model_name = result.get("model", "Unknown")
            details = result.get("details", "N/A")

            # Check if details are too long for expandable display
            if len(details) > 100:
                short_details = details[:100] + "..."
                model_items.append(
                    f"""
                <div class="unsupported-model-item">
                    <span class="model-name">{model_name}{self._generate_new_label(model_name)}{self._generate_variable_label(result)}</span>
                    <span class="model-details">
                        <span class="short-details">{short_details}</span>
                        <span class="full-details" style="display: none;">{details}</span>
                        <button class="expand-btn" onclick="toggleUnsupportedDetails(this)">Show More</button>
                    </span>
                </div>
                """
                )
            else:
                model_items.append(
                    f"""
                <div class="unsupported-model-item">
                    <span class="model-name">{model_name}{self._generate_new_label(model_name)}{self._generate_variable_label(result)}</span>
                    <span class="model-details">{details}</span>
                </div>
                """
                )

        return f"""
        <section class="section">
            <h2>‚ùå Models Without Tool Support ({len(unsupported_results)} models)</h2>
            <p style="color: #666; margin-bottom: 20px;">
                These models do not support tool calling and are listed here for reference.
            </p>
            <div class="unsupported-models-grid">
                {"".join(model_items)}
            </div>
        </section>
        """

    def _generate_charts_section(
        self, results: List[Dict[str, Any]], summary: Dict[str, Any]
    ) -> str:
        """Generate charts and visualizations section."""
        # Performance data
        avg_call_time = summary.get("avg_tool_time", 0)
        avg_response_time = summary.get("avg_response_time", 0)
        avg_total_time = summary.get("avg_total_time", 0)

        # Model categories
        total_models = len(results)
        supported_models = sum(
            1 for r in results if r.get("tool_call_support", False)
        )
        handling_models = sum(
            1
            for r in results
            if r.get("tool_call_support", False)
            and r.get("handles_response", False)
        )

        # Generate reliability chart if available
        reliability_chart = ""
        if "reliability" in summary:
            rel_stats = summary["reliability"]
            reliable_count = rel_stats.get("reliable_count", 0)
            unreliable_count = rel_stats.get("unreliable_count", 0)

            reliability_chart = f"""
            <div class="chart-container">
                <div class="chart-title">Reliability Assessment</div>
                <div class="performance-chart">
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--success-color);">{reliable_count}</div>
                        <div class="performance-label">Reliable Models</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--warning-color);">{unreliable_count}</div>
                        <div class="performance-label">Unreliable Models</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--primary-color);">{rel_stats.get('avg_tool_success_rate', 0):.1%}</div>
                        <div class="performance-label">Avg Tool Success Rate</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--primary-color);">{rel_stats.get('avg_response_success_rate', 0):.1%}</div>
                        <div class="performance-label">Avg Response Success Rate</div>
                    </div>
                </div>
            </div>
            """

        return f"""
        <section class="section">
            <h2>üìà Performance Analytics</h2>

            <div class="chart-container">
                <div class="chart-title">Model Support Categories</div>
                <div class="performance-chart">
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--success-color);">{handling_models}</div>
                        <div class="performance-label">Full Support</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--warning-color);">{supported_models - handling_models}</div>
                        <div class="performance-label">Partial Support</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--error-color);">{total_models - supported_models}</div>
                        <div class="performance-label">No Support</div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">Average Response Times</div>
                <div class="performance-chart">
                    <div class="performance-item">
                        <div class="performance-value">{avg_call_time:.2f}s</div>
                        <div class="performance-label">Tool Call Time</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value">{avg_response_time:.2f}s</div>
                        <div class="performance-label">Response Processing</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value">{avg_total_time:.2f}s</div>
                        <div class="performance-label">Total Time</div>
                    </div>
                </div>
            </div>

            {reliability_chart}
        </section>
        """

    def _generate_history_section(self) -> str:
        """Generate the history section with service-outage-style visualization."""
        if not self.history_manager:
            return ""

        # Get trackable models and status matrix
        trackable_models = self.history_manager.get_trackable_models()
        status_matrix = self.history_manager.get_status_matrix(days=30)

        if not trackable_models:
            return ""

        # Generate date headers (last 30 days)
        dates = []
        for i in range(29, -1, -1):
            date = (
                datetime.datetime.now() - datetime.timedelta(days=i)
            ).strftime("%Y-%m-%d")
            dates.append(date)

        # Generate model status rows
        model_rows = []
        for model in trackable_models:
            model_id = model["model_id"]
            display_name = model["display_name"]

            # Get status for each date
            status_cells = []
            for date in dates:
                status_data = None
                if model_id in status_matrix:
                    for status_entry in status_matrix[model_id]:
                        if status_entry["date"] == date:
                            status_data = status_entry
                            break

                if status_data:
                    status = status_data["status"]
                    details = status_data["details"]
                    css_class = f"status-{status}"

                    # Get detailed test data for rich tooltips
                    detailed_data = None
                    if self.history_manager:
                        detailed_results = (
                            self.history_manager.get_detailed_test_results(
                                model_id=model_id, days=30
                            )
                        )
                        for result in detailed_results:
                            if result["date"] == date:
                                detailed_data = result
                                break

                    # Create rich tooltip content
                    if detailed_data:
                        iterations = detailed_data["performance"]["iterations"]
                        tool_success_rate = detailed_data["performance"][
                            "tool_success_rate"
                        ]
                        response_success_rate = detailed_data["performance"][
                            "response_success_rate"
                        ]
                        total_time = detailed_data["performance"]["total_time"]

                        tooltip_content = (
                            f"Date: {date}\n"
                            f"Status: {status.title()}\n"
                            f"Iterations: {iterations}\n"
                            f"Tool Success: {tool_success_rate:.1%}\n"
                            f"Response Success: {response_success_rate:.1%}\n"
                            f"Total Time: {total_time:.2f}s"
                        )

                        # Add error details if available
                        error_msg = detailed_data["test_details"].get(
                            "error_message", ""
                        )
                        if error_msg:
                            tooltip_content += f"\nError: {error_msg[:100]}{'...' if len(error_msg) > 100 else ''}"
                    else:
                        tooltip_content = (
                            f"{date}: {details}"
                            if details
                            else f"{date}: {status}"
                        )

                    status_cells.append(
                        f'<div class="status-cell {css_class}" title="{tooltip_content}" data-date="{date}" data-model="{model_id}"></div>'
                    )
                else:
                    status_cells.append(
                        f'<div class="status-cell status-untested" title="{date}: Not tested" data-date="{date}" data-model="{model_id}"></div>'
                    )

            model_rows.append(
                f"""
                <div class="model-row">
                    <div class="model-info">
                        <span class="model-name">{display_name}{self._generate_new_label(model_id)}</span>
                    </div>
                    <div class="status-timeline">
                        {''.join(status_cells)}
                    </div>
                </div>
            """
            )

        # Generate date headers for display
        date_headers = []
        for i, date in enumerate(dates):
            # Show every 3rd date to balance readability with space
            if i % 3 == 0:
                # Try to parse date with fallback for different formats
                try:
                    display_date = datetime.datetime.strptime(
                        date, "%Y-%m-%d"
                    ).strftime("%m/%d")
                except ValueError:
                    try:
                        # Fallback for ISO format dates
                        display_date = datetime.datetime.fromisoformat(
                            date
                        ).strftime("%m/%d")
                    except ValueError:
                        # Use the raw date string if parsing fails
                        display_date = date[
                            :5
                        ]  # Show first 5 chars as fallback
                date_headers.append(
                    f'<div class="date-header">{display_date}</div>'
                )
            else:
                date_headers.append('<div class="date-header"></div>')

        # Get detailed test results for enhanced history view
        detailed_results = self.history_manager.get_detailed_test_results(
            days=30
        )
        error_analysis = self.history_manager.get_error_analysis(days=30)
        performance_trends = self.history_manager.get_performance_trends(
            days=30
        )

        # Create enhanced history section with detailed data
        detailed_history_section = self._generate_detailed_history_section(
            detailed_results, error_analysis, performance_trends
        )

        return f"""
        <section class="history-section">
            <h2>Model Performance History (Last 30 Days)</h2>
            <div class="history-legend">
                <div class="legend-item">
                    <div class="status-cell status-working"></div>
                    <span>Working Reliably</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-partial"></div>
                    <span>Tool Calls Only</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-unreliable"></div>
                    <span>Inconsistent Results</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-broken"></div>
                    <span>Previously Worked</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-untested"></div>
                    <span>Not Tested</span>
                </div>
            </div>
            <div class="history-container">
                <div class="history-chart">
                    <div class="chart-header">
                        <div class="model-header">Model</div>
                        <div class="timeline-header">
                            {''.join(date_headers)}
                        </div>
                    </div>
                    <div class="chart-body">
                        {''.join(model_rows)}
                    </div>
                </div>
            </div>
            {detailed_history_section}
        </section>
        """

    def _generate_detailed_history_section(
        self,
        detailed_results: List[Dict[str, Any]],
        error_analysis: Dict[str, Any],
        performance_trends: Dict[str, Any],
    ) -> str:
        """Generate detailed history section with error analysis and performance trends."""

        # Generate error analysis section
        error_section = ""
        if error_analysis["total_errors"] > 0:
            common_errors = error_analysis["most_common_errors"][
                :5
            ]  # Top 5 errors
            error_rows = []
            for error_msg, count in common_errors:
                error_rows.append(
                    f"""
                    <div class="error-item">
                        <div class="error-count">{count}</div>
                        <div class="error-message">{error_msg[:100]}{'...' if len(error_msg) > 100 else ''}</div>
                    </div>
                """
                )

            error_section = f"""
            <div class="error-analysis">
                <h3>Error Analysis</h3>
                <div class="error-stats">
                    <div class="stat-item">
                        <span class="stat-value">{error_analysis['total_errors']}</span>
                        <span class="stat-label">Total Errors</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">{len(error_analysis['models_with_errors'])}</span>
                        <span class="stat-label">Models with Errors</span>
                    </div>
                </div>
                <div class="common-errors">
                    <h4>Most Common Errors</h4>
                    {''.join(error_rows)}
                </div>
            </div>
            """

        # Generate performance trends section
        trends_section = ""
        if performance_trends["daily_averages"]:
            daily_data = performance_trends["daily_averages"]
            trend_rows = []

            for date, data in sorted(
                daily_data.items(), key=lambda x: x[0], reverse=True
            )[
                :7
            ]:  # Last 7 days
                trend_rows.append(
                    f"""
                    <tr>
                        <td>{date}</td>
                        <td>{data['avg_tool_time']:.3f}s</td>
                        <td>{data['avg_response_time']:.3f}s</td>
                        <td>{data['avg_success_rate']:.1%}</td>
                    </tr>
                """
                )

            trends_section = f"""
            <div class="performance-trends">
                <h3>Performance Trends</h3>
                <table class="trends-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Avg Tool Time</th>
                            <th>Avg Response Time</th>
                            <th>Success Rate</th>
                        </tr>
                    </thead>
                    <tbody>
                        {''.join(trend_rows)}
                    </tbody>
                </table>
            </div>
            """

        # Note: Recent Test Details section is now generated separately
        # in _generate_recent_test_details_section to appear in the correct order

        return f"""
        <div class="detailed-history">
            {error_section}
            {trends_section}
        </div>
        """

    def _generate_new_label(self, model_id: str) -> str:
        """Generate a NEW label for recently detected models.

        Args:
            model_id: The model ID to check

        Returns:
            str: HTML for the NEW label if the model is new, empty string otherwise
        """
        if self.history_manager and self.history_manager.is_new_model(
            model_id
        ):
            return '<span class="new-label">NEW</span>'
        return ""
    
    def _generate_variable_label(self, result: Dict[str, Any]) -> str:
        """Generate a VARIABLE label for models with conflicting results.

        Args:
            result: The result dictionary to check

        Returns:
            str: HTML for the VARIABLE label if the model has conflicting results, empty string otherwise
        """
        if result.get("has_conflicting_results", False):
            total_runs = result.get("total_test_runs", 0)
            return f'<span class="variable-label" title="Model has inconsistent results across {total_runs} tests">VARIABLE</span>'
        return ""

    def _get_javascript(self) -> str:
        """Generate JavaScript for interactive features."""
        return """
        // Filter functionality
        function initializeFilters() {
            const modelFilter = document.getElementById('model-filter');
            const supportFilter = document.getElementById('support-filter');
            const handlingFilter = document.getElementById('handling-filter');
            const table = document.getElementById('results-table');

            if (!table) return;

            function filterTable() {
                const modelValue = modelFilter ? modelFilter.value.toLowerCase() : '';
                const supportValue = supportFilter ? supportFilter.value : '';
                const handlingValue = handlingFilter ? handlingFilter.value : '';

                const rows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');

                for (let row of rows) {
                    const modelText = row.cells[0].textContent.toLowerCase();
                    const supportMatch = !supportValue || row.dataset.support === supportValue;
                    const handlingMatch = !handlingValue || row.dataset.handling === handlingValue;
                    const modelMatch = !modelValue || modelText.includes(modelValue);

                    if (modelMatch && supportMatch && handlingMatch) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                }
            }

            if (modelFilter) modelFilter.addEventListener('input', filterTable);
            if (supportFilter) supportFilter.addEventListener('change', filterTable);
            if (handlingFilter) handlingFilter.addEventListener('change', filterTable);
        }

        // Collapsible sections
        function initializeCollapsibles() {
            const headers = document.querySelectorAll('.collapsible-header');

            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const icon = this.querySelector('.expand-icon');

                    if (content.classList.contains('active')) {
                        content.classList.remove('active');
                        if (icon) icon.classList.remove('rotated');
                    } else {
                        content.classList.add('active');
                        if (icon) icon.classList.add('rotated');
                    }
                });
            });
        }

        // Toggle details in history section
        function toggleDetails(element) {
            const row = element.closest('.detail-row');
            const expandedContent = row.querySelector('.detail-expanded');

            if (expandedContent.style.display === 'none') {
                expandedContent.style.display = 'block';
                element.textContent = '‚ñ≤';
            } else {
                expandedContent.style.display = 'none';
                element.textContent = '‚ñº';
            }
        }

        function toggleUnsupportedDetails(button) {
            const shortDetails = button.parentElement.querySelector('.short-details');
            const fullDetails = button.parentElement.querySelector('.full-details');
            
            // Check if full details are hidden (either inline style or computed style)
            const isHidden = fullDetails.style.display === 'none' || 
                            window.getComputedStyle(fullDetails).display === 'none';
            
            if (isHidden) {
                shortDetails.style.display = 'none';
                fullDetails.style.display = 'block';
                button.textContent = 'Show Less';
            } else {
                shortDetails.style.display = 'inline';
                fullDetails.style.display = 'none';
                button.textContent = 'Show More';
            }
        }

        // Status cell tooltips and interactions
        function initializeStatusCells() {
            const statusCells = document.querySelectorAll('.status-cell');

            statusCells.forEach(cell => {
                cell.addEventListener('mouseenter', function(e) {
                    showTooltip(e, this.getAttribute('title'));
                });
                
                cell.addEventListener('mouseleave', function() {
                    hideTooltip();
                });
            });
        }

        function showTooltip(event, content) {
            if (!content) return;
            
            const tooltip = document.createElement('div');
            tooltip.id = 'status-tooltip';
            tooltip.innerHTML = content.replace(/\n/g, '<br>');
            tooltip.style.cssText = `
                position: absolute;
                z-index: 1000;
                background: #333;
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 0.85em;
                max-width: 300px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                pointer-events: none;
                white-space: nowrap;
            `;
            
            document.body.appendChild(tooltip);
            
            // Position tooltip near mouse
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';
            
            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            if (tooltipRect.right > window.innerWidth) {
                tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
            }
            if (tooltipRect.bottom > window.innerHeight) {
                tooltip.style.top = (rect.top - tooltipRect.height - 10) + 'px';
            }
        }

        function hideTooltip() {
            const tooltip = document.getElementById('status-tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Sort table functionality
        function initializeTableSorting() {
            const table = document.getElementById('results-table');
            if (!table) return;

            const headers = table.querySelectorAll('th');
            headers.forEach((header, index) => {
                header.style.cursor = 'pointer';
                header.addEventListener('click', () => sortTable(index));
            });
        }

        function sortTable(columnIndex) {
            const table = document.getElementById('results-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));

            // Determine sort direction
            const isAsc = table.dataset.sortDirection !== 'asc';
            table.dataset.sortDirection = isAsc ? 'asc' : 'desc';

            rows.sort((a, b) => {
                const aVal = a.cells[columnIndex].textContent.trim();
                const bVal = b.cells[columnIndex].textContent.trim();

                // Handle numeric columns (timing columns)
                if (columnIndex >= 4 && columnIndex <= 6) {
                    const aNum = parseFloat(aVal.replace('s', '')) || 0;
                    const bNum = parseFloat(bVal.replace('s', '')) || 0;
                    return isAsc ? aNum - bNum : bNum - aNum;
                }

                // Handle text columns
                return isAsc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });

            // Rebuild table
            rows.forEach(row => tbody.appendChild(row));
        }

        // Initialize all functionality when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeFilters();
            initializeCollapsibles();
            initializeStatusCells();
            initializeTableSorting();
        });

        // Make toggleDetails globally available for inline onclick handlers
        window.toggleDetails = toggleDetails;
        """

    def save_html_report(self, html_content: str, output_path: str) -> None:
        """Save HTML report to file.

        Args:
            html_content: The HTML content to save
            output_path: Path where to save the HTML file
        """
        # Ensure the directory exists
        output_dir = os.path.dirname(output_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Write the HTML file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html_content)
