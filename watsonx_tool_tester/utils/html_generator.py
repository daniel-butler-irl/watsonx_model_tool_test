#!/usr/bin/env python3
"""
HTML Report Generator for WatsonX Tool Tester.

This module provides functionality to generate beautiful HTML reports
from test results with interactive features and modern styling.
"""

import datetime
import os
from typing import Any, Dict, List, Optional

from .formatting import get_consistent_date_range, get_consistent_test_date
from .history_manager import HistoryManager
from .logging import get_logger


class HTMLReportGenerator:
    """Generator for HTML reports from test results."""

    def __init__(self, history_manager: Optional[HistoryManager] = None):
        """Initialize the HTML report generator.

        Args:
            history_manager: Optional history manager for historical data
        """
        self.title = "WatsonX Tool Test Report"
        self.description = (
            "Comprehensive analysis of AI model tool calling capabilities"
        )
        self.history_manager = history_manager

    def generate_html_report(
        self,
        results: List[Dict[str, Any]],
        summary: Dict[str, Any],
        config: Optional[Dict[str, Any]] = None,
        include_history: bool = True,
    ) -> str:
        """Generate a complete HTML report from test results.

        Args:
            results: List of test result dictionaries
            summary: Summary statistics dictionary
            config: Optional configuration information
            include_history: Whether to include historical data

        Returns:
            str: Complete HTML report as a string
        """
        # Generate report timestamp
        timestamp = datetime.datetime.utcnow().strftime(
            "%Y-%m-%d %H:%M:%S UTC"
        )

        # Build HTML structure
        # NOTE: All summary statistics and badges are calculated from current test results (results parameter)
        # Historical data (history_manager) is only used for the timeline visualization
        html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.title}</title>
    <style>
        {self._get_css_styles()}
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>{self.title}</h1>
            <p class="subtitle">{self.description}</p>
            <div class="meta-info">
                <span class="timestamp">Generated: {timestamp}</span>
                {self._generate_config_info(config)}
            </div>
        </header>

        <main>
            {self._generate_summary_section(summary, results)}
            {self._generate_history_section(results) if include_history and self.history_manager else ''}
            {self._generate_results_section(results, config)}
        </main>

        <footer class="footer">
            <p>Generated by WatsonX Tool Tester | <a href="https://github.com/daniel-butler-irl/watsonx_model_tool_test">GitHub Repository</a></p>
        </footer>
    </div>

    <script>
        {self._get_javascript()}
    </script>
</body>
</html>
"""
        return html_content

    def _get_css_styles(self) -> str:
        """Generate CSS styles for the HTML report."""
        return """
        :root {
            --primary-color: #0f62fe;
            --primary-color-light: rgba(15, 98, 254, 0.1);
            --success-color: #24a148;
            --warning-color: #f1c21b;
            --error-color: #da1e28;
            --background-color: #f4f4f4;
            --card-background: #ffffff;
            --text-color: #161616;
            --border-color: #e0e0e0;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --border-radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), #0043ce);
            color: white;
            padding: 40px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .meta-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .timestamp {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 15px;
        }

        .config-info {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .config-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 15px;
        }

        .section {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }

        .section h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
        }

        .summary-card h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .summary-card .value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-card .description {
            color: #666;
            font-size: 0.9em;
        }

        .status-indicators {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .new-label {
            background: linear-gradient(135deg, #9333ea, #7c3aed);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(147, 51, 234, 0.3);
        }

        .variable-label {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(245, 158, 11, 0.3);
            cursor: help;
        }

        .previously-working-label {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(239, 68, 68, 0.3);
            cursor: help;
        }

        .newly-working-label {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(16, 185, 129, 0.3);
            cursor: help;
        }

        .currently-broken-label {
            background: linear-gradient(135deg, #991b1b, #7f1d1d);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(153, 27, 27, 0.3);
            cursor: help;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            vertical-align: middle;
        }

        .results-table th:nth-child(2),
        .results-table th:nth-child(3),
        .results-table th:nth-child(4),
        .results-table td:nth-child(2),
        .results-table td:nth-child(3),
        .results-table td:nth-child(4) {
            text-align: center;
        }

        .results-table th {
            background: var(--background-color);
            font-weight: 600;
            color: var(--primary-color);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .results-table tr:hover {
            background: rgba(15, 98, 254, 0.05);
        }

        .model-name {
            font-weight: 600;
            color: var(--primary-color);
        }

        .support-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .support-yes {
            background: #d4edda;
            color: #155724;
        }

        .support-no {
            background: #f8d7da;
            color: #721c24;
        }

        .support-partial {
            background: #fff3cd;
            color: #856404;
        }

        .timing-info {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
        }

        .details-cell {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .details-cell:hover {
            overflow: visible;
            white-space: normal;
            word-wrap: break-word;
        }

        .reliability-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .reliability-perfect {
            background: #d4edda;
            color: #155724;
        }

        .reliability-partial {
            background: #fff3cd;
            color: #856404;
        }

        .reliability-none {
            background: #f8d7da;
            color: #721c24;
        }

        .chart-container {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            margin: 20px 0;
        }

        .chart-title {
            color: var(--primary-color);
            font-size: 1.2em;
            margin-bottom: 15px;
            text-align: center;
        }

        .performance-chart {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .performance-item {
            flex: 1;
            min-width: 200px;
            text-align: center;
            padding: 15px;
            background: var(--background-color);
            border-radius: var(--border-radius);
        }

        .performance-value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .performance-label {
            color: #666;
            font-size: 0.9em;
        }

        .filter-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-group label {
            font-weight: 500;
            color: var(--text-color);
        }

        .filter-input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 0.9em;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(15, 98, 254, 0.1);
        }

        .footer {
            text-align: center;
            padding: 20px;
            color: #666;
            border-top: 1px solid var(--border-color);
            margin-top: 40px;
        }

        .footer a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .collapsible {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin: 10px 0;
            overflow: hidden;
        }

        .collapsible-header {
            background: var(--card-background);
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            transition: background 0.2s ease;
        }

        .collapsible-header:hover {
            background: rgba(15, 98, 254, 0.05);
        }

        .collapsible-content {
            padding: 15px;
            display: none;
        }

        .collapsible-content.active {
            display: block;
        }

        .expand-icon {
            transition: transform 0.2s ease;
        }

        .expand-icon.rotated {
            transform: rotate(180deg);
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .summary-grid {
                grid-template-columns: 1fr;
            }

            .results-table {
                font-size: 0.9em;
            }

            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .performance-chart {
                flex-direction: column;
            }
        }

        /* History Section Styles */
        .history-section {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
            overflow-x: auto;
        }

        .history-container {
            min-width: 800px;
            width: 100%;
        }

        .history-legend {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .history-chart {
            background: #fafafa;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow-x: auto;
            overflow-y: hidden;
        }

        .chart-header {
            display: flex;
            background: #f0f0f0;
            border-bottom: 1px solid var(--border-color);
            min-width: max-content;
        }

        .model-header {
            min-width: 200px;
            max-width: 250px;
            padding: 12px;
            font-weight: 600;
            border-right: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .timeline-header {
            display: flex;
            flex: 1;
            min-width: 0;
        }

        .date-header {
            min-width: 24px;
            flex: 1;
            padding: 12px 2px;
            text-align: center;
            font-size: 0.7em;
            color: #666;
            writing-mode: vertical-lr;
            text-orientation: mixed;
            white-space: nowrap;
        }

        .chart-body {
            /* Removed max-height to show full table without scrollbars */
        }

        .model-row {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            min-width: max-content;
        }

        .model-row:last-child {
            border-bottom: none;
        }

        .model-info {
            min-width: 200px;
            max-width: 250px;
            padding: 12px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .model-name {
            font-weight: 600;
            font-size: 0.9em;
        }


        .status-timeline {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 8px 0;
            min-width: 0;
        }

        .status-cell {
            min-width: 24px;
            height: 24px;
            flex: 1;
            margin: 0 1px;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .status-working {
            background-color: var(--success-color);
        }

        .status-partial {
            background-color: #ff8c00;
        }

        .status-broken {
            background-color: #8b0000;
        }

        .status-not_supported {
            background-color: #e0e0e0;
        }

        .status-unreliable {
            background-color: #ffd700;
        }

        .status-untested {
            background-color: #e0e0e0;
        }

        .status-cell:hover {
            transform: scale(1.2);
            transition: transform 0.2s ease;
            z-index: 10;
            position: relative;
        }

        .status-cell[title] {
            white-space: pre-line;
        }

        /* Responsive adjustments for timeline */
        @media (max-width: 1200px) {
            .date-header {
                font-size: 0.6em;
                min-width: 20px;
            }

            .status-cell {
                min-width: 20px;
                height: 20px;
            }
        }

        @media (max-width: 900px) {
            .history-container {
                min-width: 600px;
            }

            .model-header,
            .model-info {
                min-width: 150px;
                max-width: 150px;
            }

            .date-header {
                font-size: 0.5em;
                min-width: 18px;
            }

            .status-cell {
                min-width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 768px) {
            .history-section {
                padding: 16px;
            }

            .history-container {
                min-width: 500px;
            }

            .model-header,
            .model-info {
                min-width: 120px;
                max-width: 120px;
                font-size: 0.9em;
            }

            .date-header {
                font-size: 0.4em;
                min-width: 16px;
                padding: 8px 1px;
            }

            .status-cell {
                min-width: 16px;
                height: 16px;
            }

            .chart-body {
                max-height: 400px;
            }
        }

        @media (max-width: 480px) {
            .history-container {
                min-width: 400px;
            }

            .model-header,
            .model-info {
                min-width: 100px;
                max-width: 100px;
                font-size: 0.8em;
                padding: 8px;
            }

            .date-header {
                font-size: 0.3em;
                min-width: 14px;
                padding: 6px 1px;
            }

            .status-cell {
                min-width: 14px;
                height: 14px;
                margin: 0 0.5px;
            }

            .chart-body {
                max-height: 300px;
            }

            .history-legend {
                flex-direction: column;
                gap: 10px;
            }

            .legend-item {
                font-size: 0.9em;
            }
        }

        /* Detailed History Section Styles */
        .detailed-history {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .error-analysis,
        .performance-trends,
        .detailed-results {
            margin-bottom: 30px;
        }

        .error-item {
            display: flex;
            gap: 10px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background: #fff3f3;
        }

        .error-count {
            font-weight: bold;
            color: var(--error-color);
            min-width: 50px;
            text-align: center;
        }

        .error-message {
            flex: 1;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-value {
            font-weight: bold;
            color: var(--primary-color);
        }

        .trends-table {
            width: 100%;
            border-collapse: collapse;
        }

        .trends-header {
            background: var(--background-color);
            font-weight: 600;
            color: var(--primary-color);
        }

        .trend-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .trend-date {
            width: 100px;
            color: #666;
        }

        /* Recent Test Details Table Styles */
        .details-table {
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
        }

        .details-header {
            display: flex;
            background: var(--background-color);
            font-weight: 600;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
        }

        .details-header > div {
            padding: 12px;
            border-right: 1px solid var(--border-color);
        }

        .details-header > div:last-child {
            border-right: none;
        }

        .detail-row {
            display: flex;
            align-items: center;
            padding: 0;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .detail-row:hover {
            background: rgba(15, 98, 254, 0.05);
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-row > div {
            padding: 12px;
            border-right: 1px solid var(--border-color);
        }

        .detail-row > div:last-child {
            border-right: none;
        }

        .detail-date {
            width: 80px;
            min-width: 80px;
            font-size: 0.9em;
            color: #666;
        }

        .detail-model {
            width: 300px;
            min-width: 300px;
            font-weight: 500;
            color: var(--primary-color);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .detail-status {
            width: 120px;
            min-width: 120px;
            text-align: center;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
            font-size: 0.9em;
        }

        .detail-status.working {
            background: #d4edda;
            color: #155724;
        }

        .detail-status.partial {
            background: #fff3cd;
            color: #856404;
        }

        .detail-status.broken {
            background: #f8d7da;
            color: #721c24;
        }

        .detail-status.not-supported {
            background: #e9ecef;
            color: #495057;
        }

        .detail-status.unreliable {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .detail-time {
            width: 80px;
            min-width: 80px;
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
            text-align: right;
        }

        .detail-success {
            width: 100px;
            min-width: 100px;
            font-family: monospace;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: right;
        }

        .detail-details {
            flex: 1;
            min-width: 300px;
            font-size: 0.9em;
            color: #666;
            padding: 8px;
            background: #f8f9fa;
            border-left: 3px solid #dee2e6;
            border-radius: 4px;
        }

        .details-content {
            max-height: 200px;
            overflow-y: auto;
        }

        .details-content h5 {
            margin: 0 0 8px 0;
            font-size: 0.95em;
            color: var(--primary-color);
        }

        .details-content p {
            margin: 4px 0;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .expanded-content h5 {
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .expanded-content p {
            margin-bottom: 8px;
            word-wrap: break-word;
        }

        .expanded-content strong {
            color: #495057;
        }

        /* Unsupported Models Section Styles */
        .unsupported-models-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .unsupported-model-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            transition: background-color 0.2s ease;
        }

        .unsupported-model-item:hover {
            background: #f5f5f5;
        }

        .unsupported-model-item .model-name {
            font-weight: 600;
            color: var(--text-color);
            font-size: 0.95em;
        }

        .unsupported-model-item .model-details {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
        }

        .full-details {
            display: block;
            margin-top: 8px;
            font-style: normal;
            line-height: 1.4;
        }

        /* CSS-only collapsible details styling */
        .model-details-expandable {
            margin-top: 8px;
        }

        .model-details-summary {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
            cursor: pointer;
            padding: 4px 0;
            list-style: none;
            position: relative;
        }

        .model-details-summary::-webkit-details-marker {
            display: none;
        }

        .model-details-summary::before {
            content: "▶";
            color: var(--primary-color);
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.2s ease;
        }

        .model-details-expandable[open] .model-details-summary::before {
            transform: rotate(90deg);
        }

        .model-details-summary:hover {
            color: var(--primary-color);
        }

        .model-details-full {
            font-size: 0.85em;
            color: #666;
            font-style: normal;
            line-height: 1.4;
            margin-top: 8px;
            padding-left: 16px;
        }

        @media (max-width: 768px) {
            .model-row,
            .detail-row,
            .trend-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .model-info,
            .detail-info {
                width: 100%;
                padding: 10px 0;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            .status-timeline {
                flex-direction: column;
                align-items: flex-start;
            }

            .status-cell {
                width: 100%;
                height: auto;
                padding: 8px;
                margin: 4px 0;
                border-radius: 10px;
            }

            .error-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .stat-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .trend-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .detail-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .detail-row > div {
                width: 100% !important;
                min-width: auto !important;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                padding: 8px 12px;
            }

            .detail-row > div:last-child {
                border-bottom: none;
            }

            .details-header {
                display: none;
            }

            .detail-date::before {
                content: "Date: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-model::before {
                content: "Model: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-status::before {
                content: "Status: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-time::before {
                content: "Time: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .detail-success::before {
                content: "Tool Success: ";
                font-weight: 600;
                color: var(--primary-color);
            }

            .unsupported-models-grid {
                grid-template-columns: 1fr;
            }
        }
        """

    def _generate_config_info(
        self, config: Optional[Dict[str, Any]] = None
    ) -> str:
        """Generate configuration information section."""
        if not config:
            return ""

        config_items = []

        # Add key configuration items
        if config.get("iterations"):
            config_items.append(
                f'<span class="config-item">Iterations: {config["iterations"]}</span>'
            )

        if config.get("client_type"):
            config_items.append(
                f'<span class="config-item">Client: {config["client_type"]}</span>'
            )

        if config.get("total_models"):
            config_items.append(
                f'<span class="config-item">Models Tested: {config["total_models"]}</span>'
            )

        if config_items:
            return f'<div class="config-info">{"".join(config_items)}</div>'

        return ""

    def _generate_summary_section(
        self, summary: Dict[str, Any], results: List[Dict[str, Any]]
    ) -> str:
        """Generate the summary statistics section."""
        # Use summary statistics calculated by ResultHandler to ensure consistency
        # This eliminates duplicate calculation logic and ensures single source of truth
        total_count = summary.get("total_count", 0)
        supported_count = summary.get("supported_count", 0)
        handles_response_count = summary.get("handles_response_count", 0)

        support_percentage = (
            (supported_count / total_count * 100) if total_count > 0 else 0
        )
        handling_percentage = (
            (handles_response_count / supported_count * 100)
            if supported_count > 0
            else 0
        )

        # Generate reliability info from summary statistics
        reliability_info = ""
        if "reliability" in summary:
            rel_stats = summary["reliability"]
            reliable_count = rel_stats.get("reliable_count", 0)

            # Use supported_count from summary for consistency
            reliability_percentage = (
                (reliable_count / supported_count * 100)
                if supported_count > 0
                else 0
            )

            reliability_info = f"""
            <div class="summary-card">
                <h3>Reliability</h3>
                <div class="value" style="color: var(--success-color);">{reliable_count}/{supported_count}</div>
                <div class="description">Models with 100% consistency ({reliability_percentage:.1f}%)</div>
            </div>
            """

        # Generate performance info from summary statistics
        performance_info = ""
        if summary.get("fastest_model"):
            fastest = summary["fastest_model"]
            performance_info = f"""
            <div class="summary-card">
                <h3>Fastest Model</h3>
                <div class="value" style="color: var(--primary-color);">{fastest['time']:.2f}s</div>
                <div class="description">{fastest['model']}</div>
            </div>
            """

        # Status indicators - calculate directly from current test results to ensure accuracy
        # Count directly from the results parameter (current test run data)

        # Full Support: models with tool calling AND response handling AND reliable
        full_support = sum(
            1
            for r in results
            if r.get("tool_call_support", False)
            and r.get("handles_response", False)
            and r.get("reliability", {}).get("is_reliable") is True
        )

        # Partial Support: models with tool calling but either not handling responses OR unreliable
        partial_support = sum(
            1
            for r in results
            if r.get("tool_call_support", False)
            and (
                not r.get("handles_response", False)
                or r.get("reliability", {}).get("is_reliable") is False
            )
        )

        # No Support: models without tool calling
        no_support = sum(
            1 for r in results if not r.get("tool_call_support", False)
        )

        return f"""
        <section class="section">
            <h2>📊 Summary Statistics</h2>
            <div class="summary-grid">
                <div class="summary-card">
                    <h3>Total Models</h3>
                    <div class="value">{total_count}</div>
                    <div class="description">Models tested</div>
                </div>
                <div class="summary-card">
                    <h3>Tool Support</h3>
                    <div class="value" style="color: var(--success-color);">{supported_count}</div>
                    <div class="description">Models with tool calling ({support_percentage:.1f}%)</div>
                </div>
                <div class="summary-card">
                    <h3>Response Handling</h3>
                    <div class="value" style="color: var(--success-color);">{handles_response_count}</div>
                    <div class="description">Models using tool results ({handling_percentage:.1f}%)</div>
                </div>
                {reliability_info}
                {performance_info}
                <div class="summary-card">
                    <h3>Average Response Time</h3>
                    <div class="value" style="color: var(--primary-color);">{summary.get('avg_total_time', 0):.2f}s</div>
                    <div class="description">Total processing time</div>
                </div>
            </div>

            <div class="status-indicators">
                <div class="status-badge status-success">
                    <span>✅</span>
                    <span>Full Support: {full_support}</span>
                </div>
                <div class="status-badge status-warning">
                    <span>⚠️</span>
                    <span>Partial Support: {partial_support}</span>
                </div>
                <div class="status-badge status-error">
                    <span>❌</span>
                    <span>No Support: {no_support}</span>
                </div>
            </div>
        </section>
        """

    def _generate_results_section(
        self,
        results: List[Dict[str, Any]],
        config: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Generate the detailed results table section."""
        # Group results by model to handle conflicting results
        model_results = {}
        for result in results:
            model_id = result.get("model", "unknown")
            if model_id not in model_results:
                model_results[model_id] = []
            model_results[model_id].append(result)

        # Process each model to get the best representation
        supported_results = []
        unsupported_results = []

        for model_id, model_data in model_results.items():
            # Sort by most recent or most successful test
            model_data.sort(
                key=lambda x: (
                    x.get("tool_call_support", False),  # Prefer supported
                    x.get(
                        "handles_response", False
                    ),  # Prefer handling response
                    x.get("total_time", 0),  # Prefer faster (ascending)
                ),
                reverse=True,
            )

            # Use the best result for this model
            best_result = model_data[0]

            # Add metadata about conflicting results if they exist
            if len(model_data) > 1:
                conflicting_statuses = set(
                    r.get("tool_call_support", False) for r in model_data
                )
                if len(conflicting_statuses) > 1:
                    best_result["has_conflicting_results"] = True
                    best_result["total_test_runs"] = len(model_data)
                    # Add note to details
                    original_details = best_result.get("details", "")
                    best_result["details"] = (
                        f"{original_details} (Variable results: {len(model_data)} tests)"
                    )

            # Categorize based on the best result
            if best_result.get("tool_call_support", False):
                supported_results.append(best_result)
            else:
                unsupported_results.append(best_result)

        # Check if we have reliability data (but we won't show the column)
        has_reliability = any("reliability" in result for result in results)

        # Generate main results table (supported models only)
        main_results_html = self._generate_results_table(
            supported_results, has_reliability, "supported"
        )

        # Generate unsupported models section
        unsupported_section = ""
        if unsupported_results:
            unsupported_section = self._generate_unsupported_models_section(
                unsupported_results
            )

        # Generate recent test details section if history is available
        recent_test_details = ""
        if self.history_manager:
            detailed_results = self.history_manager.get_detailed_test_results(
                days=30
            )
            if detailed_results:
                recent_test_details = (
                    self._generate_recent_test_details_section(
                        detailed_results
                    )
                )

        return f"""
        {main_results_html}
        {recent_test_details}
        {unsupported_section}
        """

    def _generate_recent_test_details_section(
        self, detailed_results: List[Dict[str, Any]]
    ) -> str:
        """Generate the latest test results section showing only results from the most recent test run."""
        if not detailed_results:
            return ""

        # Find the most recent test date
        latest_date = max(result["date"] for result in detailed_results)

        # Filter to show only results from the latest test run
        latest_results = [
            result
            for result in detailed_results
            if result["date"] == latest_date
        ]

        # Sort results by status priority and then by model name
        def get_status_priority(result):
            tool_support = result["tool_call_support"]
            handles_response = result["handles_response"]
            is_reliable = result.get("is_reliable")

            # Check if this is a model that never supported tool calling
            error_message = result["test_details"].get("error_message", "")
            details = result["test_details"].get("details", "")
            is_not_supported = not tool_support and (
                "not support" in error_message.lower()
                or "not support" in details.lower()
                or (
                    "function" in error_message.lower()
                    and "not support" in error_message.lower()
                )
            )

            # Status priority order: Working(1) -> Unreliable(2) -> Partial(3) -> Broken(4) -> Not Supported(5)
            if tool_support and handles_response and is_reliable is True:
                return (1, result["model_info"]["display_name"])  # Working
            elif tool_support and handles_response and is_reliable is False:
                return (2, result["model_info"]["display_name"])  # Unreliable
            elif tool_support and not handles_response:
                return (3, result["model_info"]["display_name"])  # Partial
            elif not tool_support and not is_not_supported:
                return (
                    4,
                    result["model_info"]["display_name"],
                )  # Broken (was working before)
            else:
                return (
                    5,
                    result["model_info"]["display_name"],
                )  # Not Supported

        latest_results.sort(key=get_status_priority)

        detail_rows = []

        for result in latest_results:
            # Determine status based on support and reliability
            tool_support = result["tool_call_support"]
            handles_response = result["handles_response"]
            is_reliable = result.get("is_reliable")

            # Check if this is a model that never supported tool calling vs one that is broken
            error_message = result["test_details"].get("error_message", "")
            details = result["test_details"].get("details", "")

            # Models that explicitly don't support tool calling
            is_not_supported = not tool_support and (
                "not support" in error_message.lower()
                or "not support" in details.lower()
                or "function" in error_message.lower()
                and "not support" in error_message.lower()
            )

            if is_not_supported:
                status_class = "not-supported"
                status_text = "Not Supported"
            elif tool_support and handles_response and is_reliable is True:
                status_class = "working"
                status_text = "Working"
            elif tool_support and handles_response and is_reliable is False:
                status_class = "unreliable"
                status_text = "Unreliable"
            elif tool_support and not handles_response:
                status_class = "partial"
                status_text = "Partial"
            else:
                status_class = "broken"
                status_text = "Broken"

            detail_rows.append(
                f"""
                <div class="detail-row" data-model="{result['model_id']}">
                    <div class="detail-date">{result['date']}</div>
                    <div class="detail-model">{result['model_info']['display_name']}{self._generate_new_label(result['model_id'])}{self._generate_previously_working_label(result['model_id'], result)}{self._generate_newly_working_label(result['model_id'], result)}{self._generate_currently_broken_label(result['model_id'], result)}</div>
                    <div class="detail-status {status_class}">{status_text}</div>
                    <div class="detail-time">{result['performance']['total_time']:.3f}s</div>
                    <div class="detail-success">{result['performance'].get('tool_success_rate', 0):.1%}</div>
                    <div class="detail-details">
                        <div class="details-content">
                            <h5>Test Details</h5>
                            {f'<p><strong>Error:</strong> {result["test_details"]["error_message"]}</p>' if result["test_details"].get("error_message") else ''}
                            {f'<p><strong>Expected:</strong> {result["test_details"]["expected_result"][:200]}{"..." if len(result["test_details"]["expected_result"]) > 200 else ""}</p>' if result["test_details"].get("expected_result") else ''}
                            {f'<p><strong>Actual:</strong> {result["test_details"]["actual_result"][:200]}{"..." if len(result["test_details"]["actual_result"]) > 200 else ""}</p>' if result["test_details"].get("actual_result") else ''}
                            <p><strong>Details:</strong> {result['test_details']['details']}</p>
                        </div>
                    </div>
                </div>
            """
            )

        return f"""
        <section class="section">
            <h2>📋 Latest Test Results</h2>
            <p style="color: #666; margin-bottom: 20px;">
                Results from the most recent test execution ({latest_date})
            </p>
            <div class="detailed-results">
                <div class="details-table">
                    <div class="details-header">
                        <div class="detail-date">Date</div>
                        <div class="detail-model">Model</div>
                        <div class="detail-status">Status</div>
                        <div class="detail-time">Time</div>
                        <div class="detail-success">Tool Success</div>
                        <div class="detail-details">Details</div>
                    </div>
                    {''.join(detail_rows)}
                </div>
            </div>
        </section>
        """

    def _generate_results_table(
        self,
        results: List[Dict[str, Any]],
        has_reliability: bool,
        table_type: str,
    ) -> str:
        """Generate a results table for the given results."""
        # Generate table rows
        rows = []
        for result in results:
            model_name = result.get("model", "Unknown")
            tool_support = result.get("tool_call_support", False)
            handles_response = result.get("handles_response", False)
            details = result.get("details", "N/A")

            # Calculate tool successes for use in both tool support and response handling
            tool_successes = 0
            iterations = 1

            # Format tool support with reliability context
            if has_reliability and "reliability" in result:
                rel_info = result["reliability"]
                is_reliable = rel_info.get("is_reliable")
                tool_success_rate = rel_info.get("tool_call_success_rate", 0)
                iterations = rel_info.get("iterations", 1)

                # Calculate actual success count from rate and iterations
                tool_successes = int(tool_success_rate * iterations)

                # Show success/total format for supported models (only consider tool calling success)
                if tool_support and is_reliable is not None:
                    if tool_success_rate == 1.0:
                        tool_support_html = f'<span class="support-indicator support-yes">✅ Reliable ({tool_successes}/{iterations})</span>'
                    else:
                        tool_support_html = f'<span class="support-indicator support-partial">⚠️ Unreliable ({tool_successes}/{iterations})</span>'
                elif not tool_support:
                    # For unsupported models, show 0/iterations
                    tool_support_html = f'<span class="support-indicator support-no">❌ Not Supported (0/{iterations})</span>'
                else:
                    tool_support_html = f'<span class="support-indicator support-{"yes" if tool_support else "no"}">{"✅ Yes" if tool_support else "❌ No"}</span>'
            else:
                # For models without reliability data, assume 1 success if tool_support is True
                tool_successes = 1 if tool_support else 0
                tool_support_html = f'<span class="support-indicator support-{"yes" if tool_support else "no"}">{"✅ Yes" if tool_support else "❌ No"}</span>'

            # Format response handling with reliability context
            if has_reliability and "reliability" in result:
                rel_info = result["reliability"]
                is_reliable = rel_info.get("is_reliable")
                response_success_rate = rel_info.get(
                    "response_handling_success_rate", 0
                )

                # Calculate actual success count from rate and tool_successes
                response_successes = (
                    int(response_success_rate * tool_successes)
                    if tool_successes > 0
                    else 0
                )

                # Show response handling based on model support
                if not tool_support:
                    # For unsupported models, show N/A
                    response_support_html = '<span class="support-indicator" style="color: #888;">N/A</span>'
                elif tool_support and tool_successes > 0:
                    # For supported models, show success/attempts format
                    if response_success_rate == 1.0:
                        response_support_html = f'<span class="support-indicator support-yes">✅ Correct ({response_successes}/{tool_successes})</span>'
                    elif response_success_rate > 0:
                        response_support_html = f'<span class="support-indicator support-partial">⚠️ Partial ({response_successes}/{tool_successes})</span>'
                    else:
                        response_support_html = f'<span class="support-indicator support-no">❌ Never Handles (0/{tool_successes})</span>'
                else:
                    response_support_html = f'<span class="support-indicator support-{"yes" if handles_response else "no"}">{"✅ Yes" if handles_response else "❌ No"}</span>'
            else:
                response_support_html = f'<span class="support-indicator support-{"yes" if handles_response else "no"}">{"✅ Yes" if handles_response else "❌ No"}</span>'

            # Reliability info is now shown in tooltips only, not in a separate column

            # Format timing info
            # Handle both nested response_times structure and flat CSV structure
            times = result.get("response_times", {})

            # Try nested structure first, then fall back to flat CSV columns
            call_time = times.get("tool_call_time", 0) or result.get(
                "tool_call_time", 0
            )
            resp_time = times.get("response_processing_time", 0) or result.get(
                "response_time", 0
            )
            total_time = times.get("total_time", 0) or result.get(
                "total_time", 0
            )

            call_time_html = (
                f'<span class="timing-info">{call_time:.2f}s</span>'
                if call_time
                else "N/A"
            )
            resp_time_html = (
                f'<span class="timing-info">{resp_time:.2f}s</span>'
                if resp_time
                else "N/A"
            )
            total_time_html = (
                f'<span class="timing-info">{total_time:.2f}s</span>'
                if total_time
                else "N/A"
            )

            # Truncate details for display
            details_html = f'<span class="details-cell" title="{details}">{details}</span>'

            # No reliability column

            row = f"""
            <tr data-model="{model_name.lower()}" data-support="{tool_support}" data-handling="{handles_response}">
                <td class="model-name">{model_name}{self._generate_new_label(model_name)}{self._generate_variable_label(result)}{self._generate_previously_working_label(model_name, result)}{self._generate_newly_working_label(model_name, result)}{self._generate_currently_broken_label(model_name, result)}</td>
                <td>{tool_support_html}</td>
                <td>{response_support_html}</td>
                <td>{call_time_html}</td>
                <td>{resp_time_html}</td>
                <td>{total_time_html}</td>
                <td>{details_html}</td>
            </tr>
            """
            rows.append(row)

        # Determine section title and filter controls based on table type
        section_title = (
            "🔍 Models with Tool Support"
            if table_type == "supported"
            else "🔍 Detailed Results"
        )
        filter_controls = ""
        if table_type == "supported":
            filter_controls = """
            <div class="filter-controls">
                <div class="filter-group">
                    <label for="model-filter">Filter by Model:</label>
                    <input type="text" id="model-filter" class="filter-input" placeholder="Enter model name...">
                </div>
                <div class="filter-group">
                    <label for="reliability-filter">Reliability:</label>
                    <select id="reliability-filter" class="filter-input">
                        <option value="">All</option>
                        <option value="reliable">Reliable</option>
                        <option value="unreliable">Unreliable</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="handling-filter">Response Handling:</label>
                    <select id="handling-filter" class="filter-input">
                        <option value="">All</option>
                        <option value="true">Correct</option>
                        <option value="false">Incorrect</option>
                    </select>
                </div>
            </div>
            """

        return f"""
        <section class="section">
            <h2>{section_title}</h2>

            {filter_controls}

            <table class="results-table" id="results-table">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Tool Support</th>
                        <th>Response Handling</th>
                        <th>Call Time</th>
                        <th>Response Time</th>
                        <th>Total Time</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    {"".join(rows)}
                </tbody>
            </table>
        </section>
        """

    def _generate_unsupported_models_section(
        self, unsupported_results: List[Dict[str, Any]]
    ) -> str:
        """Generate a section for models that don't support tool calling."""
        if not unsupported_results:
            return ""

        # Create a simple list of unsupported models
        model_items = []
        for i, result in enumerate(unsupported_results):
            model_name = result.get("model", "Unknown")
            details = result.get("details", "N/A")

            # Check if details are too long for expandable display
            if len(details) > 100:
                short_details = details[:100] + "..."
                model_items.append(
                    f"""
                <div class="unsupported-model-item">
                    <span class="model-name">{model_name}{self._generate_new_label(model_name)}{self._generate_variable_label(result)}{self._generate_previously_working_label(model_name, result)}{self._generate_newly_working_label(model_name, result)}{self._generate_currently_broken_label(model_name, result)}</span>
                    <details class="model-details-expandable">
                        <summary class="model-details-summary">{short_details}</summary>
                        <div class="model-details-full">{details}</div>
                    </details>
                </div>
                """
                )
            else:
                model_items.append(
                    f"""
                <div class="unsupported-model-item">
                    <span class="model-name">{model_name}{self._generate_new_label(model_name)}{self._generate_variable_label(result)}{self._generate_previously_working_label(model_name, result)}{self._generate_newly_working_label(model_name, result)}{self._generate_currently_broken_label(model_name, result)}</span>
                    <span class="model-details">{details}</span>
                </div>
                """
                )

        return f"""
        <section class="section">
            <h2>❌ Models Without Tool Support ({len(unsupported_results)} models)</h2>
            <p style="color: #666; margin-bottom: 20px;">
                These models do not support tool calling and are listed here for reference.
            </p>
            <div class="unsupported-models-grid">
                {"".join(model_items)}
            </div>
        </section>
        """

    def _generate_charts_section(
        self, results: List[Dict[str, Any]], summary: Dict[str, Any]
    ) -> str:
        """Generate charts and visualizations section."""
        # Performance data
        avg_call_time = summary.get("avg_tool_time", 0)
        avg_response_time = summary.get("avg_response_time", 0)
        avg_total_time = summary.get("avg_total_time", 0)

        # Model categories from summary statistics
        total_models = summary.get("total_count", 0)
        supported_models = summary.get("supported_count", 0)
        handling_models = summary.get("handles_response_count", 0)

        # Generate reliability chart if available
        reliability_chart = ""
        if "reliability" in summary:
            rel_stats = summary["reliability"]
            reliable_count = rel_stats.get("reliable_count", 0)
            unreliable_count = rel_stats.get("unreliable_count", 0)

            reliability_chart = f"""
            <div class="chart-container">
                <div class="chart-title">Reliability Assessment</div>
                <div class="performance-chart">
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--success-color);">{reliable_count}</div>
                        <div class="performance-label">Reliable Models</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--warning-color);">{unreliable_count}</div>
                        <div class="performance-label">Unreliable Models</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--primary-color);">{rel_stats.get('avg_tool_success_rate', 0):.1%}</div>
                        <div class="performance-label">Avg Tool Success Rate</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--primary-color);">{rel_stats.get('avg_response_success_rate', 0):.1%}</div>
                        <div class="performance-label">Avg Response Success Rate</div>
                    </div>
                </div>
            </div>
            """

        return f"""
        <section class="section">
            <h2>📈 Performance Analytics</h2>

            <div class="chart-container">
                <div class="chart-title">Model Support Categories</div>
                <div class="performance-chart">
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--success-color);">{handling_models}</div>
                        <div class="performance-label">Full Support</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--warning-color);">{supported_models - handling_models}</div>
                        <div class="performance-label">Partial Support</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value" style="color: var(--error-color);">{total_models - supported_models}</div>
                        <div class="performance-label">No Support</div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">Average Response Times</div>
                <div class="performance-chart">
                    <div class="performance-item">
                        <div class="performance-value">{avg_call_time:.2f}s</div>
                        <div class="performance-label">Tool Call Time</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value">{avg_response_time:.2f}s</div>
                        <div class="performance-label">Response Processing</div>
                    </div>
                    <div class="performance-item">
                        <div class="performance-value">{avg_total_time:.2f}s</div>
                        <div class="performance-label">Total Time</div>
                    </div>
                </div>
            </div>

            {reliability_chart}
        </section>
        """

    def _has_test_execution_for_date(self, target_date: str) -> bool:
        """
        Directly check if any tests were executed for the given date.

        This method provides a robust check by directly querying the CSV file
        rather than relying on complex status matrix processing that can fail.

        Args:
            target_date: Date string in YYYY-MM-DD format

        Returns:
            True if any test results exist for the target date, False otherwise
        """
        logger = get_logger("html_generator")

        if not self.history_manager:
            logger.debug(
                f"Timeline check for {target_date}: No history manager available"
            )
            return False

        import csv
        import os

        results_file = self.history_manager.results_file
        if not os.path.exists(results_file):
            logger.debug(
                f"Timeline check for {target_date}: Results file {results_file} does not exist"
            )
            return False

        # Track what dates we actually find for debugging
        found_dates = set()
        target_matches = 0

        try:
            with open(results_file, "r") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    row_date = row.get("date")
                    if row_date:
                        found_dates.add(row_date)
                        if row_date == target_date:
                            target_matches += 1

            # Log debugging information about the search
            logger.debug(
                f"Timeline check for {target_date}: Found {len(found_dates)} unique dates in CSV"
            )
            logger.debug(
                f"Timeline check for {target_date}: Found {target_matches} entries for target date"
            )

            if target_matches == 0:
                # Log recent dates to help with debugging timing issues
                recent_dates = sorted(found_dates)[-5:] if found_dates else []
                logger.info(
                    f"Timeline notice: No test results found for {target_date}. Recent dates in CSV: {recent_dates}. Expected today: {get_consistent_test_date()}"
                )
            else:
                logger.debug(
                    f"Timeline check for {target_date}: Successfully found test data"
                )

            return target_matches > 0

        except (IOError, csv.Error) as e:
            logger.warning(
                f"Timeline check for {target_date}: Error reading CSV file {results_file}: {e}"
            )
            return False

    def _generate_history_section(
        self, current_results: List[Dict[str, Any]]
    ) -> str:
        """Generate the history section with service-outage-style visualization.

        Args:
            current_results: Current test results to use for latest day badge calculations
        """
        if not self.history_manager:
            return ""

        # Get trackable models and status matrix
        trackable_models = self.history_manager.get_trackable_models()
        status_matrix = self.history_manager.get_status_matrix(days=30)

        if not trackable_models:
            return ""

        # Generate date headers (last 30 days) - use consistent date function
        dates = get_consistent_date_range(30)

        # Generate model status rows
        model_rows = []
        for model in trackable_models:
            model_id = model["model_id"]
            display_name = model["display_name"]

            # Get latest result data for badge logic from current test results
            latest_result = None
            for result in current_results:
                if result.get("model") == model_id:
                    latest_result = result
                    break

            # Get status for each date
            status_cells = []
            today = get_consistent_test_date()

            for date in dates:
                status_data = None

                # For today's date, use current results instead of historical status matrix
                if date == today and latest_result:
                    # Calculate status from current result using same logic as history manager
                    tool_support = latest_result.get(
                        "tool_call_support", False
                    )
                    handles_response = latest_result.get(
                        "handles_response", False
                    )
                    is_reliable = latest_result.get("reliability", {}).get(
                        "is_reliable", False
                    )

                    if tool_support and handles_response and is_reliable:
                        status = "working"
                        details = "Full tool calling support - reliable"
                    elif tool_support and handles_response and not is_reliable:
                        status = "unreliable"
                        details = (
                            "Full tool calling support - inconsistent results"
                        )
                    elif tool_support and not handles_response:
                        status = "partial"
                        details = (
                            "Tool calling only - doesn't handle responses"
                        )
                    elif not tool_support:
                        status = "not_supported"
                        details = "Model does not support tool calling"
                    else:
                        status = "broken"
                        details = "Tool calling failed"

                    # Create status data structure consistent with historical data
                    status_data = {
                        "status": status,
                        "details": details,
                        "date": date,
                    }
                else:
                    # For historical dates, use status matrix as before
                    if model_id in status_matrix:
                        for status_entry in status_matrix[model_id]:
                            if status_entry["date"] == date:
                                status_data = status_entry
                                break

                if status_data:
                    status = status_data["status"]
                    details = status_data["details"]
                    css_class = f"status-{status}"

                    # Get detailed test data for rich tooltips
                    detailed_data = None

                    # For today's date, use current results for tooltip data
                    if date == today and latest_result:
                        # Create detailed data structure from current result
                        detailed_data = {
                            "date": date,
                            "performance": {
                                "iterations": latest_result.get(
                                    "reliability", {}
                                ).get("iterations", 1),
                                "tool_success_rate": latest_result.get(
                                    "reliability", {}
                                ).get("tool_success_rate", 0.0),
                                "response_success_rate": latest_result.get(
                                    "reliability", {}
                                ).get("response_success_rate", 0.0),
                                "total_time": latest_result.get(
                                    "response_times", {}
                                ).get("total_time", 0.0),
                            },
                            "test_details": {
                                "error_message": latest_result.get(
                                    "error_message", ""
                                ),
                                "details": latest_result.get("details", ""),
                                "expected_result": latest_result.get(
                                    "expected_result", ""
                                ),
                                "actual_result": latest_result.get(
                                    "actual_result", ""
                                ),
                            },
                        }
                    elif self.history_manager:
                        # For historical dates, use history manager data
                        detailed_results = (
                            self.history_manager.get_detailed_test_results(
                                model_id=model_id, days=30
                            )
                        )
                        for result in detailed_results:
                            if result["date"] == date:
                                detailed_data = result
                                break

                    # Create rich tooltip content
                    if detailed_data:
                        iterations = detailed_data["performance"]["iterations"]
                        tool_success_rate = detailed_data["performance"][
                            "tool_success_rate"
                        ]
                        response_success_rate = detailed_data["performance"][
                            "response_success_rate"
                        ]
                        total_time = detailed_data["performance"]["total_time"]

                        tooltip_content = (
                            f"Date: {date}\n"
                            f"Status: {status.title()}\n"
                            f"Iterations: {iterations}\n"
                            f"Tool Success: {tool_success_rate:.1%}\n"
                            f"Response Success: {response_success_rate:.1%}\n"
                            f"Total Time: {total_time:.2f}s"
                        )

                        # Add error details if available
                        error_msg = detailed_data["test_details"].get(
                            "error_message", ""
                        )
                        if error_msg:
                            tooltip_content += f"\nError: {error_msg[:100]}{'...' if len(error_msg) > 100 else ''}"
                    else:
                        tooltip_content = (
                            f"{date}: {details}"
                            if details
                            else f"{date}: {status}"
                        )

                    status_cells.append(
                        f'<div class="status-cell {css_class}" title="{tooltip_content}" data-date="{date}" data-model="{model_id}"></div>'
                    )
                else:
                    status_cells.append(
                        f'<div class="status-cell status-untested" title="{date}: Not tested" data-date="{date}" data-model="{model_id}"></div>'
                    )

            # Format current result for badge generation methods
            badge_result = None
            if latest_result:
                badge_result = {
                    "tool_call_support": latest_result.get(
                        "tool_call_support", False
                    ),
                    "handles_response": latest_result.get(
                        "handles_response", False
                    ),
                    "reliability": {
                        "is_reliable": latest_result.get(
                            "reliability", {}
                        ).get("is_reliable", False)
                    },
                }

            model_rows.append(
                f"""
                <div class="model-row">
                    <div class="model-info">
                        <span class="model-name">{display_name}{self._generate_new_label(model_id)}{self._generate_previously_working_label(model_id, badge_result) if badge_result else ""}{self._generate_newly_working_label(model_id, badge_result) if badge_result else ""}{self._generate_currently_broken_label(model_id, badge_result) if badge_result else ""}</span>
                    </div>
                    <div class="status-timeline">
                        {''.join(status_cells)}
                    </div>
                </div>
            """
            )

        # Validate for missing test execution - use direct CSV check to avoid false positives
        latest_date = dates[-1] if dates else None
        blank_column_warning = ""
        if latest_date:
            # Use direct CSV file check instead of complex status matrix processing
            # This prevents false positives when tests ran but status matrix processing fails
            has_test_data_today = self._has_test_execution_for_date(
                latest_date
            )

            # Only show warning if there is genuinely no test data for today
            # This is extremely conservative to prevent false positives
            if not has_test_data_today:
                blank_column_warning = f"""
                <div style="background: #fff3cd; color: #856404; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffeaa7;">
                    <strong>⚠️ Timeline Notice:</strong> No test results found for {latest_date}.
                    This indicates the daily test pipeline may not have executed successfully.
                    Please check the pipeline logs and CSV data file.
                </div>
                """

        # Generate date headers for display
        date_headers = []
        for i, date in enumerate(dates):
            # Show every 3rd date to balance readability with space
            if i % 3 == 0:
                # Try to parse date with fallback for different formats
                try:
                    display_date = datetime.datetime.strptime(
                        date, "%Y-%m-%d"
                    ).strftime("%m/%d")
                except ValueError:
                    try:
                        # Fallback for ISO format dates
                        display_date = datetime.datetime.fromisoformat(
                            date
                        ).strftime("%m/%d")
                    except ValueError:
                        # Use the raw date string if parsing fails
                        display_date = date[
                            :5
                        ]  # Show first 5 chars as fallback
                date_headers.append(
                    f'<div class="date-header">{display_date}</div>'
                )
            else:
                date_headers.append('<div class="date-header"></div>')

        # Get detailed test results for enhanced history view
        detailed_results = self.history_manager.get_detailed_test_results(
            days=30
        )
        error_analysis = self.history_manager.get_error_analysis(days=30)
        performance_trends = self.history_manager.get_performance_trends(
            days=30
        )

        # Create enhanced history section with detailed data
        detailed_history_section = self._generate_detailed_history_section(
            detailed_results, error_analysis, performance_trends
        )

        return f"""
        <section class="history-section">
            <h2>Model Performance History (Last 30 Days)</h2>
            {blank_column_warning}
            <div class="history-legend">
                <div class="legend-item">
                    <div class="status-cell status-working"></div>
                    <span>Working Reliably</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-partial"></div>
                    <span>Tool Calls Only</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-unreliable"></div>
                    <span>Inconsistent Results</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-broken"></div>
                    <span>Previously Worked</span>
                </div>
                <div class="legend-item">
                    <div class="status-cell status-untested"></div>
                    <span>Not Tested</span>
                </div>
            </div>
            <div class="history-container">
                <div class="history-chart">
                    <div class="chart-header">
                        <div class="model-header">Model</div>
                        <div class="timeline-header">
                            {''.join(date_headers)}
                        </div>
                    </div>
                    <div class="chart-body">
                        {''.join(model_rows)}
                    </div>
                </div>
            </div>
            {detailed_history_section}
        </section>
        """

    def _generate_detailed_history_section(
        self,
        detailed_results: List[Dict[str, Any]],
        error_analysis: Dict[str, Any],
        performance_trends: Dict[str, Any],
    ) -> str:
        """Generate detailed history section with error analysis and performance trends."""

        # Generate error analysis section
        error_section = ""
        if error_analysis["total_errors"] > 0:
            common_errors = error_analysis["most_common_errors"][
                :5
            ]  # Top 5 errors
            error_rows = []
            for error_msg, count in common_errors:
                error_rows.append(
                    f"""
                    <div class="error-item">
                        <div class="error-count">{count}</div>
                        <div class="error-message">{error_msg[:100]}{'...' if len(error_msg) > 100 else ''}</div>
                    </div>
                """
                )

            error_section = f"""
            <div class="error-analysis">
                <h3>Error Analysis</h3>
                <div class="error-stats">
                    <div class="stat-item">
                        <span class="stat-value">{error_analysis['total_errors']}</span>
                        <span class="stat-label">Total Errors</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">{len(error_analysis['models_with_errors'])}</span>
                        <span class="stat-label">Models with Errors</span>
                    </div>
                </div>
                <div class="common-errors">
                    <h4>Most Common Errors</h4>
                    {''.join(error_rows)}
                </div>
            </div>
            """

        # Generate performance trends section
        trends_section = ""
        if performance_trends["daily_averages"]:
            daily_data = performance_trends["daily_averages"]
            trend_rows = []

            for date, data in sorted(
                daily_data.items(), key=lambda x: x[0], reverse=True
            )[
                :7
            ]:  # Last 7 days
                # Calculate success rate for supported models only
                supported_success_rate = data.get(
                    "supported_models_success_rate",
                    data.get("avg_success_rate", 0),
                )

                trend_rows.append(
                    f"""
                    <div class="detail-row">
                        <div style="width: 100px; min-width: 100px; padding: 12px; border-right: 1px solid var(--border-color);">{date}</div>
                        <div style="width: 120px; min-width: 120px; padding: 12px; border-right: 1px solid var(--border-color); text-align: center; font-family: monospace;">{data['avg_tool_time']:.3f}s</div>
                        <div style="width: 120px; min-width: 120px; padding: 12px; border-right: 1px solid var(--border-color); text-align: center; font-family: monospace;">{data['avg_response_time']:.3f}s</div>
                        <div style="width: 100px; min-width: 100px; padding: 12px; text-align: center; font-family: monospace; color: var(--primary-color);">{supported_success_rate:.1%}</div>
                    </div>
                """
                )

            trends_section = f"""
            <div class="performance-trends">
                <h3>Performance Trends</h3>
                <div class="details-table">
                    <div class="details-header">
                        <div style="width: 100px; min-width: 100px;">Date</div>
                        <div style="width: 120px; min-width: 120px;">Avg Tool Time</div>
                        <div style="width: 120px; min-width: 120px;">Avg Response Time</div>
                        <div style="width: 100px; min-width: 100px;">Success Rate</div>
                    </div>
                    {''.join(trend_rows)}
                </div>
            </div>
            """

        # Note: Recent Test Details section is now generated separately
        # in _generate_recent_test_details_section to appear in the correct order

        return f"""
        <div class="detailed-history">
            {error_section}
            {trends_section}
        </div>
        """

    def _generate_new_label(self, model_id: str) -> str:
        """Generate a NEW label for recently detected models.

        Args:
            model_id: The model ID to check

        Returns:
            str: HTML for the NEW label if the model is new, empty string otherwise
        """
        if self.history_manager and self.history_manager.is_new_model(
            model_id
        ):
            return '<span class="new-label">NEW</span>'
        return ""

    def _generate_variable_label(self, result: Dict[str, Any]) -> str:
        """Generate a VARIABLE label for models with conflicting results.

        Args:
            result: The result dictionary to check

        Returns:
            str: HTML for the VARIABLE label if the model has conflicting results, empty string otherwise
        """
        if result.get("has_conflicting_results", False):
            total_runs = result.get("total_test_runs", 0)
            return f'<span class="variable-label" title="Model has inconsistent results across {total_runs} tests">VARIABLE</span>'
        return ""

    def _generate_previously_working_label(
        self, model_id: str, result: Dict[str, Any]
    ) -> str:
        """Generate a PREVIOUSLY WORKING label for models that were working but now aren't.

        Args:
            model_id: The model ID to check
            result: The result dictionary to check

        Returns:
            str: HTML for the PREVIOUSLY WORKING label if applicable, empty string otherwise
        """
        if (
            self.history_manager
            and self.history_manager.is_previously_working(model_id, result)
        ):
            return '<span class="previously-working-label" title="Model was working recently but is now broken/unreliable">PREVIOUSLY WORKING</span>'
        return ""

    def _generate_newly_working_label(
        self, model_id: str, result: Dict[str, Any]
    ) -> str:
        """Generate a NEWLY WORKING label for models that are newly working.

        Args:
            model_id: The model ID to check
            result: The result dictionary to check

        Returns:
            str: HTML for the NEWLY WORKING label if applicable, empty string otherwise
        """
        if self.history_manager and self.history_manager.is_newly_working(
            model_id, result
        ):
            return '<span class="newly-working-label" title="Model was not working before but is working now">NEWLY WORKING</span>'
        return ""

    def _generate_currently_broken_label(
        self, model_id: str, result: Dict[str, Any]
    ) -> str:
        """Generate a CURRENTLY BROKEN label for models that were working but are now completely broken.

        Args:
            model_id: The model ID to check
            result: The result dictionary to check

        Returns:
            str: HTML for the CURRENTLY BROKEN label if applicable, empty string otherwise
        """
        if self.history_manager and self.history_manager.is_currently_broken(
            model_id, result
        ):
            return '<span class="currently-broken-label" title="Model was working but is now completely broken">CURRENTLY BROKEN</span>'
        return ""

    def _get_javascript(self) -> str:
        """Generate JavaScript for interactive features."""
        return """
        // Filter functionality
        function initializeFilters() {
            const modelFilter = document.getElementById('model-filter');
            const supportFilter = document.getElementById('support-filter');
            const handlingFilter = document.getElementById('handling-filter');
            const table = document.getElementById('results-table');

            if (!table) return;

            function filterTable() {
                const modelValue = modelFilter ? modelFilter.value.toLowerCase() : '';
                const supportValue = supportFilter ? supportFilter.value : '';
                const handlingValue = handlingFilter ? handlingFilter.value : '';

                const rows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');

                for (let row of rows) {
                    const modelText = row.cells[0].textContent.toLowerCase();
                    const supportMatch = !supportValue || row.dataset.support === supportValue;
                    const handlingMatch = !handlingValue || row.dataset.handling === handlingValue;
                    const modelMatch = !modelValue || modelText.includes(modelValue);

                    if (modelMatch && supportMatch && handlingMatch) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                }
            }

            if (modelFilter) modelFilter.addEventListener('input', filterTable);
            if (supportFilter) supportFilter.addEventListener('change', filterTable);
            if (handlingFilter) handlingFilter.addEventListener('change', filterTable);
        }

        // Collapsible sections
        function initializeCollapsibles() {
            const headers = document.querySelectorAll('.collapsible-header');

            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const icon = this.querySelector('.expand-icon');

                    if (content.classList.contains('active')) {
                        content.classList.remove('active');
                        if (icon) icon.classList.remove('rotated');
                    } else {
                        content.classList.add('active');
                        if (icon) icon.classList.add('rotated');
                    }
                });
            });
        }

        // Toggle details in history section
        function toggleDetails(element) {
            const row = element.closest('.detail-row');
            const expandedContent = row.querySelector('.detail-expanded');

            if (expandedContent.style.display === 'none') {
                expandedContent.style.display = 'block';
                element.textContent = '▲';
            } else {
                expandedContent.style.display = 'none';
                element.textContent = '▼';
            }
        }


        // Status cell tooltips and interactions
        function initializeStatusCells() {
            const statusCells = document.querySelectorAll('.status-cell');

            statusCells.forEach(cell => {
                cell.addEventListener('mouseenter', function(e) {
                    showTooltip(e, this.getAttribute('title'));
                });

                cell.addEventListener('mouseleave', function() {
                    hideTooltip();
                });
            });
        }

        function showTooltip(event, content) {
            if (!content) return;

            const tooltip = document.createElement('div');
            tooltip.id = 'status-tooltip';
            tooltip.innerHTML = content.replace(/\n/g, '<br>');
            tooltip.style.cssText = `
                position: absolute;
                z-index: 1000;
                background: #333;
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 0.85em;
                max-width: 300px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                pointer-events: none;
                white-space: nowrap;
            `;

            document.body.appendChild(tooltip);

            // Position tooltip near mouse
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            if (tooltipRect.right > window.innerWidth) {
                tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
            }
            if (tooltipRect.bottom > window.innerHeight) {
                tooltip.style.top = (rect.top - tooltipRect.height - 10) + 'px';
            }
        }

        function hideTooltip() {
            const tooltip = document.getElementById('status-tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }

        // Sort table functionality
        function initializeTableSorting() {
            const table = document.getElementById('results-table');
            if (!table) return;

            const headers = table.querySelectorAll('th');
            headers.forEach((header, index) => {
                header.style.cursor = 'pointer';
                header.addEventListener('click', () => sortTable(index));
            });
        }

        function sortTable(columnIndex) {
            const table = document.getElementById('results-table');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));

            // Determine sort direction
            const isAsc = table.dataset.sortDirection !== 'asc';
            table.dataset.sortDirection = isAsc ? 'asc' : 'desc';

            rows.sort((a, b) => {
                const aVal = a.cells[columnIndex].textContent.trim();
                const bVal = b.cells[columnIndex].textContent.trim();

                // Handle numeric columns (timing columns)
                if (columnIndex >= 4 && columnIndex <= 6) {
                    const aNum = parseFloat(aVal.replace('s', '')) || 0;
                    const bNum = parseFloat(bVal.replace('s', '')) || 0;
                    return isAsc ? aNum - bNum : bNum - aNum;
                }

                // Handle text columns
                return isAsc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });

            // Rebuild table
            rows.forEach(row => tbody.appendChild(row));
        }

        // Model navigation functionality
        function initializeModelNavigation() {
            const modelNames = document.querySelectorAll('.model-name');

            modelNames.forEach(modelName => {
                // Make model names clickable
                modelName.style.cursor = 'pointer';
                modelName.style.textDecoration = 'underline';
                modelName.style.color = 'var(--primary-color)';

                modelName.addEventListener('click', function(e) {
                    e.preventDefault();

                    // Extract model ID from the clicked element
                    const modelText = this.textContent.replace(/NEW|VARIABLE|PREVIOUSLY WORKING|NEWLY WORKING|CURRENTLY BROKEN/g, '').trim();
                    const modelId = modelText.toLowerCase();

                    // Try to find the model in the results table
                    const resultsTable = document.getElementById('results-table');
                    if (resultsTable) {
                        const rows = resultsTable.querySelectorAll('tr[data-model]');
                        for (let row of rows) {
                            if (row.dataset.model === modelId || row.dataset.model.includes(modelId)) {
                                // Scroll to the row
                                row.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'center'
                                });

                                // Highlight the row temporarily
                                row.style.transition = 'background-color 0.3s ease';
                                row.style.backgroundColor = 'var(--primary-color-light)';

                                setTimeout(() => {
                                    row.style.backgroundColor = '';
                                }, 2000);

                                return;
                            }
                        }
                    }

                    // If not found in results table, try to find in history section
                    const historySection = document.querySelector('.history-section');
                    if (historySection) {
                        const detailRows = historySection.querySelectorAll('.detail-row[data-model]');
                        for (let row of detailRows) {
                            if (row.dataset.model === modelId || row.dataset.model.includes(modelId)) {
                                row.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'center'
                                });

                                // Highlight the row temporarily
                                row.style.transition = 'background-color 0.3s ease';
                                row.style.backgroundColor = 'var(--primary-color-light)';

                                setTimeout(() => {
                                    row.style.backgroundColor = '';
                                }, 2000);

                                return;
                            }
                        }
                    }
                });
            });
        }

        // Initialize all functionality when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeFilters();
            initializeCollapsibles();
            initializeStatusCells();
            initializeTableSorting();
            initializeModelNavigation();
        });

        // Make toggleDetails globally available for inline onclick handlers
        window.toggleDetails = toggleDetails;
        """

    def save_html_report(self, html_content: str, output_path: str) -> None:
        """Save HTML report to file.

        Args:
            html_content: The HTML content to save
            output_path: Path where to save the HTML file
        """
        # Ensure the directory exists
        output_dir = os.path.dirname(output_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Write the HTML file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(html_content)
